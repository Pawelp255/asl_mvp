<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ASL Fingerspelling MVP (Local Profiles + Recorder)</title>
  <style>
    :root {
      --bg:#fff; --fg:#111; --muted:#555; --border:#ddd; --soft:#fafafa;
      --primary:#111; --danger:#b00020;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; color:var(--fg); background:var(--bg); }
    h1 { margin: 0 0 8px 0; }
    .muted { color: var(--muted); }
    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .panel { border:1px solid var(--border); border-radius:12px; padding:12px; background:#fff; flex: 1 1 520px; min-width: 300px; }
    video, canvas { width: 520px; max-width:100%; border-radius:12px; background:#000; }
    .big { font-size: 22px; font-weight: 700; }
    button, select, input { padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    button:active { transform: translateY(1px); }
    textarea { width:520px; max-width:100%; height:120px; border-radius:12px; padding:10px; border:1px solid var(--border); }
    .badge { display:inline-block; padding: 4px 10px; border-radius:999px; border:1px solid var(--border); background:var(--soft); }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
    .hr { height:1px; background:#eee; margin:10px 0; }
    label.small { font-size:12px; color: var(--muted); display:block; margin: 0 0 6px 0; }
    .inline { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin: 12px 0; }
    .tabBtn { padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:var(--soft); }
    .tabBtn.active { background:#111; color:#fff; border-color:#111; }
    .hide { display:none !important; }

    /* Desktop: panels side-by-side, mobile safe (stack by default) */
    @media (min-width: 1100px) {
      .row { flex-wrap: nowrap; }
      .panel { flex: 0 0 calc(50% - 8px); }
    }

    /* Modal */
    .modalOverlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 18px;
    }
    .modal {
      width: min(560px, 100%);
      background: #fff;
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.3);
    }
    .modalTitle { font-weight:800; font-size:18px; margin-bottom:6px; }
    .modalActions { display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }
    .btnPrimary { background:#111; color:#fff; border-color:#111; }
    .btnGhost { background:#fff; }
    .btnDanger { background: var(--danger); color:#fff; border-color: var(--danger); }

    .kpi { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .kpi .badge { background:#f6f6f6; }
  </style>
</head>
<body>
  <h1>ASL Fingerspelling MVP (Local Profiles + Recorder)</h1>
  <div class="muted">
    Local inference (no cloud). MediaPipe Tasks Vision HandLandmarker + TF.js kNN.
    Use <b>Profiles</b> to separate datasets (your demo vs your friend's recording).
  </div>

  <div class="tabs">
    <button class="tabBtn active" id="tabDemoBtn">Demo</button>
    <button class="tabBtn" id="tabRecorderBtn">Recorder</button>
    <button class="tabBtn" id="tabProfilesBtn">Profiles</button>
  </div>

  <!-- Profiles / Mode bar -->
  <div class="inline" style="margin: 6px 0 14px 0;">
    <span class="badge">Active profile: <b id="activeProfileName">—</b></span>
    <span class="badge">Mode: <b id="activeProfileMode">—</b></span>
    <button id="switchProfileBtn">Switch / Create Profile</button>
    <span class="badge" id="status">Idle</span>
  </div>

  <!-- DEMO TAB -->
  <div id="tabDemo">
    <div class="row">
      <div class="panel">
        <div class="muted">Camera</div>
        <video id="video" playsinline autoplay muted></video>

        <div class="inline" style="margin-top:10px;">
          <button id="startBtn">Start</button>
          <button id="stopBtn" disabled>Stop</button>
          <button id="clearTextBtn">Clear text</button>
        </div>

        <div class="hr"></div>

        <div class="grid">
          <div>
            <label class="small">Stabilization window (frames)</label>
            <input id="stabWindow" type="number" min="3" max="30" value="12" />
          </div>
          <div>
            <label class="small">Required majority (0.50–0.95)</label>
            <input id="stabMajority" type="number" step="0.05" min="0.5" max="0.95" value="0.7" />
          </div>
          <div>
            <label class="small">Min confidence (0–1)</label>
            <input id="minConf" type="number" step="0.05" min="0" max="1" value="0.55" />
          </div>
          <div>
            <label class="small">Emit debounce (ms)</label>
            <input id="emitDebounce" type="number" min="150" max="4000" value="900" />
          </div>
        </div>

        <div class="hr"></div>
        <div class="mono">
          Demo tip: Use this tab to test recognition quality. Recorder tab is for clean sample capture.
        </div>
      </div>

      <div class="panel">
        <div class="muted">Live View + Output</div>
        <canvas id="canvas"></canvas>

        <div style="margin-top:10px;">
          <div class="big">Stable: <span id="stableLabel">—</span></div>
          <div class="big">Raw: <span id="rawLabel">—</span></div>
          <div class="muted">Confidence: <span id="conf">—</span> | Hand used: <span id="handInfo">—</span></div>
        </div>

        <div class="hr"></div>

        <div class="inline">
          <label class="small" style="margin:0;">ASL label (train):</label>
          <select id="aslLabel">
            <option value="A">A</option><option value="B">B</option><option value="C">C</option><option value="D">D</option><option value="E">E</option>
            <option value="F">F</option><option value="G">G</option><option value="H">H</option><option value="I">I</option>
            <option value="K">K</option><option value="L">L</option><option value="M">M</option><option value="N">N</option><option value="O">O</option>
            <option value="P">P</option><option value="Q">Q</option><option value="R">R</option><option value="S">S</option><option value="T">T</option>
            <option value="U">U</option><option value="V">V</option><option value="W">W</option><option value="X">X</option><option value="Y">Y</option>
            <option value="SPACE">SPACE</option>
            <option value="BACKSPACE">BACKSPACE</option>
          </select>

          <button id="addSampleBtn">Add sample</button>
          <button id="clearSamplesBtn">Clear samples</button>
          <span class="badge">Samples: <span id="sampleCount">0</span></span>
        </div>

        <div class="inline" style="margin-top:10px;">
          <button id="exportBtn">Export JSON</button>
          <label class="badge" style="cursor:pointer;">
            Import JSON
            <input id="importInput" type="file" accept="application/json" style="display:none;">
          </label>
        </div>

        <div class="hr"></div>

        <div class="muted">Transcript</div>
        <textarea id="transcript" placeholder="Letters will appear here..."></textarea>

        <div class="mono" style="margin-top:8px;">
          Notes: Detects up to 2 hands; classification uses the largest hand (dominant by bbox area).
        </div>
      </div>
    </div>
  </div>

  <!-- RECORDER TAB -->
  <div id="tabRecorder" class="hide">
    <div class="row">
      <div class="panel">
        <div class="muted">Recorder Camera</div>
        <video id="videoRec" playsinline autoplay muted></video>

        <div class="inline" style="margin-top:10px;">
          <button id="recStartBtn">Start recording</button>
          <button id="recStopBtn" disabled>Stop</button>
          <button id="recResetLetterBtn">Reset current letter</button>
        </div>

        <div class="hr"></div>
        <div class="kpi">
          <span class="badge">Target: <b id="recTargetLabel">—</b></span>
          <span class="badge">Progress: <b id="recProgress">0/30</b></span>
          <span class="badge">Auto-capture: <b id="recAutoState">OFF</b></span>
          <span class="badge">Stable raw: <b id="recRawLabel">—</b></span>
          <span class="badge">Conf: <b id="recConf">—</b></span>
        </div>

        <div class="hr"></div>
        <div class="grid">
          <div>
            <label class="small">Goal per letter</label>
            <input id="recGoal" type="number" min="5" max="200" value="30" />
          </div>
          <div>
            <label class="small">Min confidence</label>
            <input id="recMinConf" type="number" step="0.05" min="0" max="1" value="0.70" />
          </div>
          <div>
            <label class="small">Hold stable (ms)</label>
            <input id="recHoldMs" type="number" min="100" max="3000" value="450" />
          </div>
          <div>
            <label class="small">Cooldown between samples (ms)</label>
            <input id="recCooldownMs" type="number" min="50" max="3000" value="220" />
          </div>
        </div>

        <div class="hr"></div>
        <div class="mono">
          Recorder rules: one dominant hand; auto-capture adds a sample only when the prediction is stable enough and held for the required time.
          After <b>30/30</b>, recording stops and you must confirm the next letter (Stop & Confirm).
        </div>
      </div>

      <div class="panel">
        <div class="muted">Recorder Live View</div>
        <canvas id="canvasRec"></canvas>

        <div class="hr"></div>

        <div class="inline">
          <button id="recPrevBtn">Prev</button>
          <button id="recNextBtn">Next</button>
          <span class="badge">Letters: A–Y (no J/Z)</span>
        </div>

        <div class="hr"></div>

        <div class="inline">
          <button id="recExportBtn">Export profile JSON</button>
          <label class="badge" style="cursor:pointer;">
            Import into profile
            <input id="recImportInput" type="file" accept="application/json" style="display:none;">
          </label>
        </div>

        <div class="mono" style="margin-top:8px;">
          Tip: Use <b>your friend</b> profile in Recording mode. Use your profile in Demo mode for presentation/testing.
        </div>
      </div>
    </div>
  </div>

  <!-- PROFILES TAB -->
  <div id="tabProfiles" class="hide">
    <div class="panel">
      <div class="muted">Profiles (Local)</div>
      <div class="hr"></div>

      <div class="inline">
        <span class="badge">Profiles stored in this browser (LocalStorage)</span>
      </div>

      <div class="hr"></div>

      <div class="inline">
        <label class="small" style="margin:0;">Select</label>
        <select id="profileSelect"></select>
        <button id="profileActivateBtn" class="btnPrimary">Activate</button>
        <button id="profileDeleteBtn" class="btnDanger">Delete</button>
      </div>

      <div class="hr"></div>

      <div class="grid">
        <div>
          <label class="small">New profile name</label>
          <input id="newProfileName" placeholder="e.g., FriendRecorder" />
        </div>
        <div>
          <label class="small">Mode</label>
          <select id="newProfileMode">
            <option value="recording">Recording</option>
            <option value="demo">Demo</option>
          </select>
        </div>
      </div>
      <div class="inline" style="margin-top:10px;">
        <button id="profileCreateBtn">Create profile</button>
        <span class="badge">Active samples: <span id="activeSamplesKpi">0</span></span>
      </div>

      <div class="hr"></div>

      <div class="mono">
        Note: Profiles are per-device/per-browser. To move between laptops, use Export JSON on Recorder/Demo and Import on the other device.
      </div>
    </div>
  </div>

  <!-- Profile Switch Modal -->
  <div class="modalOverlay" id="profileModal">
    <div class="modal">
      <div class="modalTitle">Switch / Create Profile</div>
      <div class="muted">Pick an existing profile or create a new one. Mode controls which tab is intended (Recording vs Demo).</div>
      <div class="hr"></div>

      <div class="inline">
        <label class="small" style="margin:0;">Existing</label>
        <select id="profileModalSelect"></select>
        <button id="profileModalActivateBtn" class="btnPrimary">Activate</button>
      </div>

      <div class="hr"></div>

      <div class="grid">
        <div>
          <label class="small">New profile name</label>
          <input id="profileModalNewName" placeholder="e.g., BossDemo / FriendRecording" />
        </div>
        <div>
          <label class="small">Mode</label>
          <select id="profileModalNewMode">
            <option value="recording">Recording</option>
            <option value="demo">Demo</option>
          </select>
        </div>
      </div>
      <div class="inline" style="margin-top:10px;">
        <button id="profileModalCreateBtn">Create & Activate</button>
        <button id="profileModalCloseBtn" class="btnGhost">Close</button>
      </div>
    </div>
  </div>

  <!-- Recorder Advance Overlay (Option A) -->
  <div class="modalOverlay" id="advanceOverlay">
    <div class="modal">
      <div class="modalTitle">Letter completed</div>
      <div class="muted" id="advanceMsg">—</div>
      <div class="hr"></div>
      <div class="modalActions">
        <button id="advanceStayBtn" class="btnGhost">Stay on current</button>
        <button id="advanceContinueBtn" class="btnPrimary">Continue</button>
      </div>
    </div>
  </div>

  <!-- TF.js + kNN -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2/dist/knn-classifier.min.js"></script>

  <script type="module">
    import { FilesetResolver, HandLandmarker, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    // -----------------------------
    // Tabs
    // -----------------------------
    const tabDemoBtn = document.getElementById("tabDemoBtn");
    const tabRecorderBtn = document.getElementById("tabRecorderBtn");
    const tabProfilesBtn = document.getElementById("tabProfilesBtn");
    const tabDemo = document.getElementById("tabDemo");
    const tabRecorder = document.getElementById("tabRecorder");
    const tabProfiles = document.getElementById("tabProfiles");

    function setActiveTab(name) {
      tabDemoBtn.classList.toggle("active", name === "demo");
      tabRecorderBtn.classList.toggle("active", name === "recorder");
      tabProfilesBtn.classList.toggle("active", name === "profiles");
      tabDemo.classList.toggle("hide", name !== "demo");
      tabRecorder.classList.toggle("hide", name !== "recorder");
      tabProfiles.classList.toggle("hide", name !== "profiles");
    }

    tabDemoBtn.addEventListener("click", () => setActiveTab("demo"));
    tabRecorderBtn.addEventListener("click", () => setActiveTab("recorder"));
    tabProfilesBtn.addEventListener("click", () => setActiveTab("profiles"));

    // -----------------------------
    // UI refs (top bar)
    // -----------------------------
    const activeProfileNameEl = document.getElementById("activeProfileName");
    const activeProfileModeEl = document.getElementById("activeProfileMode");
    const switchProfileBtn = document.getElementById("switchProfileBtn");
    const statusEl = document.getElementById("status");
    function setStatus(s) { statusEl.textContent = s; }

    // -----------------------------
    // Demo refs
    // -----------------------------
    const videoEl = document.getElementById("video");
    const canvasEl = document.getElementById("canvas");
    const ctx = canvasEl.getContext("2d");

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const clearTextBtn = document.getElementById("clearTextBtn");

    const stableLabelEl = document.getElementById("stableLabel");
    const rawLabelEl = document.getElementById("rawLabel");
    const confEl = document.getElementById("conf");
    const handInfoEl = document.getElementById("handInfo");
    const transcriptEl = document.getElementById("transcript");

    const aslLabelEl = document.getElementById("aslLabel");
    const addSampleBtn = document.getElementById("addSampleBtn");
    const clearSamplesBtn = document.getElementById("clearSamplesBtn");
    const sampleCountEl = document.getElementById("sampleCount");
    const exportBtn = document.getElementById("exportBtn");
    const importInput = document.getElementById("importInput");

    const stabWindowEl = document.getElementById("stabWindow");
    const stabMajorityEl = document.getElementById("stabMajority");
    const minConfEl = document.getElementById("minConf");
    const emitDebounceEl = document.getElementById("emitDebounce");

    // -----------------------------
    // Recorder refs
    // -----------------------------
    const videoRec = document.getElementById("videoRec");
    const canvasRec = document.getElementById("canvasRec");
    const ctxRec = canvasRec.getContext("2d");

    const recStartBtn = document.getElementById("recStartBtn");
    const recStopBtn = document.getElementById("recStopBtn");
    const recResetLetterBtn = document.getElementById("recResetLetterBtn");

    const recTargetLabelEl = document.getElementById("recTargetLabel");
    const recProgressEl = document.getElementById("recProgress");
    const recAutoStateEl = document.getElementById("recAutoState");
    const recRawLabelEl = document.getElementById("recRawLabel");
    const recConfEl = document.getElementById("recConf");

    const recGoalEl = document.getElementById("recGoal");
    const recMinConfEl = document.getElementById("recMinConf");
    const recHoldMsEl = document.getElementById("recHoldMs");
    const recCooldownMsEl = document.getElementById("recCooldownMs");

    const recPrevBtn = document.getElementById("recPrevBtn");
    const recNextBtn = document.getElementById("recNextBtn");

    const recExportBtn = document.getElementById("recExportBtn");
    const recImportInput = document.getElementById("recImportInput");

    // Advance overlay (Option A)
    const advanceOverlay = document.getElementById("advanceOverlay");
    const advanceMsg = document.getElementById("advanceMsg");
    const advanceStayBtn = document.getElementById("advanceStayBtn");
    const advanceContinueBtn = document.getElementById("advanceContinueBtn");

    // Profiles tab refs
    const profileSelect = document.getElementById("profileSelect");
    const profileActivateBtn = document.getElementById("profileActivateBtn");
    const profileDeleteBtn = document.getElementById("profileDeleteBtn");
    const newProfileName = document.getElementById("newProfileName");
    const newProfileMode = document.getElementById("newProfileMode");
    const profileCreateBtn = document.getElementById("profileCreateBtn");
    const activeSamplesKpi = document.getElementById("activeSamplesKpi");

    // Profile modal refs
    const profileModal = document.getElementById("profileModal");
    const profileModalSelect = document.getElementById("profileModalSelect");
    const profileModalActivateBtn = document.getElementById("profileModalActivateBtn");
    const profileModalNewName = document.getElementById("profileModalNewName");
    const profileModalNewMode = document.getElementById("profileModalNewMode");
    const profileModalCreateBtn = document.getElementById("profileModalCreateBtn");
    const profileModalCloseBtn = document.getElementById("profileModalCloseBtn");

    // -----------------------------
    // kNN classifier (shared)
    // -----------------------------
    const knn = knnClassifier.create();

    // -----------------------------
    // MediaPipe Tasks Vision
    // -----------------------------
    let handLandmarker = null;
    let drawingUtils = null;

    let streamDemo = null;
    let rafDemo = null;
    let lastDominantLandmarks = null;

    let streamRec = null;
    let rafRec = null;
    let lastRecDominantLandmarks = null;

    // -----------------------------
    // Local profiles (LocalStorage)
    // -----------------------------
    const LS_KEY = "asl_profiles_v1";
    const LS_ACTIVE = "asl_active_profile_v1";

    function loadProfiles() {
      try {
        const raw = localStorage.getItem(LS_KEY);
        const obj = raw ? JSON.parse(raw) : {};
        return (obj && typeof obj === "object") ? obj : {};
      } catch { return {}; }
    }
    function saveProfiles(p) {
      localStorage.setItem(LS_KEY, JSON.stringify(p));
    }
    function ensureDefaultProfiles() {
      const p = loadProfiles();
      const keys = Object.keys(p);
      if (keys.length === 0) {
        p["BossDemo"] = { mode: "demo", datasetJSON: null, createdAt: Date.now() };
        p["FriendRecording"] = { mode: "recording", datasetJSON: null, createdAt: Date.now() };
        saveProfiles(p);
        localStorage.setItem(LS_ACTIVE, "BossDemo");
      } else if (!localStorage.getItem(LS_ACTIVE)) {
        localStorage.setItem(LS_ACTIVE, keys[0]);
      }
    }

    function datasetToJSON(dataset) {
      const out = {};
      for (const label of Object.keys(dataset)) {
        const t = dataset[label];
        out[label] = { shape: t.shape, data: Array.from(t.dataSync()) };
      }
      return out;
    }
    function jsonToDataset(obj) {
      const ds = {};
      for (const label of Object.keys(obj)) {
        const { shape, data } = obj[label];
        ds[label] = tf.tensor(data, shape);
      }
      return ds;
    }

    function setActiveProfile(name) {
      const profiles = loadProfiles();
      if (!profiles[name]) return;

      // save current dataset into currently active profile first
      persistActiveProfileDataset();

      // switch
      localStorage.setItem(LS_ACTIVE, name);
      const prof = profiles[name];

      activeProfileNameEl.textContent = name;
      activeProfileModeEl.textContent = prof.mode;

      // load dataset into knn
      knn.clearAllClasses();
      if (prof.datasetJSON) {
        try {
          const ds = jsonToDataset(prof.datasetJSON);
          knn.setClassifierDataset(ds);
        } catch (e) {
          console.warn("Failed to load datasetJSON for profile", name, e);
        }
      }

      refreshProfileUI();

      // Suggest tab based on mode (non-destructive)
      if (prof.mode === "recording") setActiveTab("recorder");
      else setActiveTab("demo");

      // Update counters
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();
      updateRecorderHeader();
      setStatus("Idle");
    }

    function getActiveProfileName() {
      return localStorage.getItem(LS_ACTIVE) || "";
    }

    function persistActiveProfileDataset() {
      const name = getActiveProfileName();
      if (!name) return;
      const profiles = loadProfiles();
      if (!profiles[name]) return;

      const ds = knn.getClassifierDataset();
      const json = datasetToJSON(ds);

      profiles[name].datasetJSON = json;
      profiles[name].updatedAt = Date.now();
      saveProfiles(profiles);
    }

    function refreshProfileUI() {
      const profiles = loadProfiles();
      const names = Object.keys(profiles).sort((a,b)=>a.localeCompare(b));
      const active = getActiveProfileName();

      function fillSelect(sel) {
        sel.innerHTML = "";
        for (const n of names) {
          const opt = document.createElement("option");
          opt.value = n; opt.textContent = `${n} (${profiles[n].mode})`;
          if (n === active) opt.selected = true;
          sel.appendChild(opt);
        }
      }
      fillSelect(profileSelect);
      fillSelect(profileModalSelect);

      // top bar
      if (profiles[active]) {
        activeProfileNameEl.textContent = active;
        activeProfileModeEl.textContent = profiles[active].mode;
      } else {
        activeProfileNameEl.textContent = "—";
        activeProfileModeEl.textContent = "—";
      }

      activeSamplesKpi.textContent = knn.getNumExamples();
    }

    function createProfile(name, mode) {
      name = (name || "").trim();
      if (!name) return { ok:false, msg:"Profile name is required." };

      const profiles = loadProfiles();
      if (profiles[name]) return { ok:false, msg:"Profile already exists." };

      profiles[name] = { mode, datasetJSON: null, createdAt: Date.now() };
      saveProfiles(profiles);
      return { ok:true };
    }

    function deleteProfile(name) {
      const profiles = loadProfiles();
      if (!profiles[name]) return;
      delete profiles[name];
      saveProfiles(profiles);

      // if deleted active, switch to any remaining
      const names = Object.keys(profiles);
      if (getActiveProfileName() === name) {
        localStorage.setItem(LS_ACTIVE, names[0] || "");
      }
      refreshProfileUI();
      const newActive = getActiveProfileName();
      if (newActive) setActiveProfile(newActive);
    }

    // -----------------------------
    // Vector normalization
    // -----------------------------
    function landmarksToNormalizedVector(lm) {
      const base = lm[0];
      const dx1 = lm[5].x - base.x, dy1 = lm[5].y - base.y, dz1 = (lm[5].z ?? 0) - (base.z ?? 0);
      const dx2 = lm[9].x - base.x, dy2 = lm[9].y - base.y, dz2 = (lm[9].z ?? 0) - (base.z ?? 0);
      const s1 = Math.hypot(dx1, dy1, dz1);
      const s2 = Math.hypot(dx2, dy2, dz2);
      const scale = Math.max(1e-6, (s1 + s2) / 2);

      const v = [];
      for (const p of lm) {
        v.push((p.x - base.x) / scale);
        v.push((p.y - base.y) / scale);
        v.push(((p.z ?? 0) - (base.z ?? 0)) / scale);
      }

      let norm = 0;
      for (const x of v) norm += x * x;
      norm = Math.sqrt(Math.max(1e-12, norm));
      for (let i = 0; i < v.length; i++) v[i] /= norm;

      return v;
    }

    // -----------------------------
    // Dominant hand selection (largest bbox)
    // -----------------------------
    function bboxAreaFromLandmarks(lm) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of lm) {
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
      }
      const w = Math.max(0, maxX - minX);
      const h = Math.max(0, maxY - minY);
      return w * h;
    }
    function pickDominantHandIndex(result) {
      const lms = result.landmarks || [];
      if (lms.length === 0) return -1;
      if (lms.length === 1) return 0;
      let bestIdx = 0, bestArea = -1;
      for (let i = 0; i < lms.length; i++) {
        const area = bboxAreaFromLandmarks(lms[i]);
        if (area > bestArea) { bestArea = area; bestIdx = i; }
      }
      return bestIdx;
    }
    function handednessLabel(result, idx) {
      try {
        const h = result.handedness?.[idx]?.[0];
        if (!h) return null;
        return `${h.categoryName} (${(h.score ?? 0).toFixed(2)})`;
      } catch { return null; }
    }

    // -----------------------------
    // Demo stabilization
    // -----------------------------
    let predHistory = [];
    let lastEmitted = { label: null, t: 0 };

    function addPrediction(label, conf) {
      const windowN = Math.max(3, Math.min(30, parseInt(stabWindowEl.value || "12", 10)));
      predHistory.push({ label, conf, t: Date.now() });
      if (predHistory.length > windowN) predHistory.shift();
    }
    function getStablePrediction() {
      if (predHistory.length === 0) return { label: null, conf: 0, ratio: 0 };

      const minConf = Math.max(0, Math.min(1, parseFloat(minConfEl.value || "0.55")));
      const majority = Math.max(0.5, Math.min(0.95, parseFloat(stabMajorityEl.value || "0.7")));

      const counts = new Map();
      const confSum = new Map();
      let considered = 0;

      for (const p of predHistory) {
        if (p.conf < minConf) continue;
        considered++;
        counts.set(p.label, (counts.get(p.label) || 0) + 1);
        confSum.set(p.label, (confSum.get(p.label) || 0) + p.conf);
      }
      if (considered === 0) return { label: null, conf: 0, ratio: 0 };

      let bestLabel = null, bestCount = -1, bestAvgConf = -1;
      for (const [label, c] of counts.entries()) {
        const avg = (confSum.get(label) || 0) / c;
        if (c > bestCount || (c === bestCount && avg > bestAvgConf)) {
          bestLabel = label; bestCount = c; bestAvgConf = avg;
        }
      }
      const ratio = bestCount / considered;
      if (ratio >= majority) return { label: bestLabel, conf: bestAvgConf, ratio };
      return { label: null, conf: bestAvgConf, ratio };
    }

    function emitIfStable(label) {
      if (!label) return;
      const now = Date.now();
      const debounceMs = Math.max(150, Math.min(4000, parseInt(emitDebounceEl.value || "900", 10)));
      if (lastEmitted.label === label && (now - lastEmitted.t) < (debounceMs + 250)) return;
      if ((now - lastEmitted.t) < debounceMs) return;

      if (label === "BACKSPACE") transcriptEl.value = transcriptEl.value.slice(0, -1);
      else if (label === "SPACE") transcriptEl.value += " ";
      else transcriptEl.value += label;

      lastEmitted = { label, t: now };
    }

    // -----------------------------
    // MediaPipe init
    // -----------------------------
    async function initHandLandmarker() {
      setStatus("Loading model…");
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
        },
        runningMode: "VIDEO",
        numHands: 2
      });
      drawingUtils = new DrawingUtils(ctx);
    }

    // -----------------------------
    // Drawing
    // -----------------------------
    function ensureCanvasSizeFor(video, canvas) {
      const w = video.videoWidth || 640;
      const h = video.videoHeight || 480;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
    }

    function drawHandsOn(video, canvas, context, result) {
      ensureCanvasSizeFor(video, canvas);
      context.save();
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      const lms = result.landmarks || [];
      if (lms.length > 0) {
        const du = new DrawingUtils(context);
        for (const lm of lms) {
          du.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 3 });
          du.drawLandmarks(lm, { lineWidth: 2 });
        }
      }
      context.restore();
    }

    // -----------------------------
    // Predict (shared)
    // -----------------------------
    async function knnPredict(lm) {
      if (knn.getNumExamples() <= 0) return { label: null, conf: 0 };

      const vec = landmarksToNormalizedVector(lm);
      const tensor = tf.tensor(vec, [1, vec.length]);
      const pred = await knn.predictClass(tensor, 5);
      const label = pred.label;
      const conf = (pred.confidences && pred.confidences[label]) ? pred.confidences[label] : 0;
      return { label, conf };
    }

    // -----------------------------
    // DEMO loop
    // -----------------------------
    async function demoStep() {
      if (!handLandmarker) return;
      const now = performance.now();
      const result = handLandmarker.detectForVideo(videoEl, now);

      drawHandsOn(videoEl, canvasEl, ctx, result);

      const lms = result.landmarks || [];
      if (lms.length === 0) {
        lastDominantLandmarks = null;
        predHistory = [];
        rawLabelEl.textContent = "—";
        stableLabelEl.textContent = "—";
        confEl.textContent = "—";
        handInfoEl.textContent = "—";
      } else {
        const idx = pickDominantHandIndex(result);
        lastDominantLandmarks = lms[idx];
        handInfoEl.textContent = handednessLabel(result, idx) || `#${idx}`;

        const pred = await knnPredict(lastDominantLandmarks);
        if (!pred.label) {
          rawLabelEl.textContent = "NO SAMPLES";
          stableLabelEl.textContent = "Train first";
          confEl.textContent = "—";
        } else {
          rawLabelEl.textContent = pred.label;
          confEl.textContent = pred.conf.toFixed(2);
          addPrediction(pred.label, pred.conf);
          const stable = getStablePrediction();
          stableLabelEl.textContent = stable.label ? `${stable.label} (ratio ${stable.ratio.toFixed(2)})` : `— (ratio ${stable.ratio.toFixed(2)})`;
          emitIfStable(stable.label);
        }
      }
      rafDemo = requestAnimationFrame(demoStep);
    }

    async function demoStart() {
      if (rafDemo) return;
      setStatus("Starting…");
      if (!handLandmarker) await initHandLandmarker();

      streamDemo = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
      videoEl.srcObject = streamDemo;
      await videoEl.play();

      setStatus("Running");
      startBtn.disabled = true;
      stopBtn.disabled = false;

      rafDemo = requestAnimationFrame(demoStep);
    }

    function demoStop() {
      if (rafDemo) cancelAnimationFrame(rafDemo);
      rafDemo = null;
      if (streamDemo) { streamDemo.getTracks().forEach(t => t.stop()); streamDemo = null; }
      videoEl.srcObject = null;

      setStatus("Idle");
      startBtn.disabled = false;
      stopBtn.disabled = true;

      predHistory = [];
      lastEmitted = { label: null, t: 0 };
      lastDominantLandmarks = null;
      rawLabelEl.textContent = "—";
      stableLabelEl.textContent = "—";
      confEl.textContent = "—";
      handInfoEl.textContent = "—";
    }

    // -----------------------------
    // DEMO training + import/export
    // -----------------------------
    function downloadJSON(filename, obj) {
      const blob = new Blob([JSON.stringify(obj)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    exportBtn.addEventListener("click", () => {
      persistActiveProfileDataset();
      const active = getActiveProfileName();
      const profiles = loadProfiles();
      const prof = profiles[active];
      downloadJSON(`${active || "profile"}_knn.json`, {
        profile: active,
        mode: prof?.mode || "demo",
        dataset: prof?.datasetJSON || datasetToJSON(knn.getClassifierDataset()),
        exportedAt: new Date().toISOString()
      });
    });

    importInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      const obj = JSON.parse(text);

      // Support both raw dataset JSON and wrapped export
      const dsObj = obj.dataset ? obj.dataset : obj;
      try {
        const ds = jsonToDataset(dsObj);
        knn.setClassifierDataset(ds);
        sampleCountEl.textContent = knn.getNumExamples();
        activeSamplesKpi.textContent = knn.getNumExamples();
        persistActiveProfileDataset();
        alert("Imported into active profile.");
      } catch (err) {
        console.error(err);
        alert("Import failed. File format not recognized.");
      }
      importInput.value = "";
    });

    addSampleBtn.addEventListener("click", () => {
      if (!lastDominantLandmarks) { alert("No hand detected. Show your hand to the camera first."); return; }
      const label = aslLabelEl.value;
      const vec = landmarksToNormalizedVector(lastDominantLandmarks);
      const tensor = tf.tensor(vec, [1, vec.length]);
      knn.addExample(tensor, label);
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();
      persistActiveProfileDataset();
    });

    clearSamplesBtn.addEventListener("click", () => {
      if (!confirm("Clear ALL samples for active profile?")) return;
      knn.clearAllClasses();
      sampleCountEl.textContent = 0;
      activeSamplesKpi.textContent = 0;
      predHistory = [];
      lastEmitted = { label: null, t: 0 };
      rawLabelEl.textContent = "—";
      stableLabelEl.textContent = "—";
      confEl.textContent = "—";
      persistActiveProfileDataset();
      updateRecorderHeader();
    });

    clearTextBtn.addEventListener("click", () => {
      transcriptEl.value = "";
      predHistory = [];
      lastEmitted = { label: null, t: 0 };
    });

    startBtn.addEventListener("click", () => demoStart().catch(err => {
      console.error(err);
      setStatus("Error");
      alert("Could not start. Use Chrome/Edge and run via http://localhost:8000 (not file://). Check camera permissions.");
      demoStop();
    }));
    stopBtn.addEventListener("click", demoStop);

    // -----------------------------
    // Recorder logic (auto-capture)
    // -----------------------------
    const LABELS = ["A","B","C","D","E","F","G","H","I","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y"];

    let recLabelIndex = 0;
    let recIsRunning = false;
    let recLastSampleAt = 0;
    let recStableSince = 0;
    let recPrevVec = null;
    let pendingAdvance = null; // {fromLabel,toLabel}

    function getRecTargetLabel() { return LABELS[recLabelIndex] || "A"; }

    function getDatasetCountsFromKnn() {
      const ds = knn.getClassifierDataset();
      const counts = {};
      for (const label of Object.keys(ds)) {
        const t = ds[label];
        // number of examples = first dimension
        counts[label] = t.shape?.[0] || 0;
      }
      return counts;
    }

    function updateRecorderHeader() {
      const label = getRecTargetLabel();
      recTargetLabelEl.textContent = label;

      const goal = Math.max(5, Math.min(200, parseInt(recGoalEl.value || "30", 10)));
      const counts = getDatasetCountsFromKnn();
      const n = counts[label] || 0;

      recProgressEl.textContent = `${n}/${goal}`;
      recAutoStateEl.textContent = recIsRunning ? "ON" : "OFF";
    }

    function showAdvanceOverlay(fromLabel, toLabel) {
      const goal = Math.max(5, Math.min(200, parseInt(recGoalEl.value || "30", 10)));
      pendingAdvance = { fromLabel, toLabel };
      advanceMsg.textContent = `${fromLabel} complete (${goal}/${goal}). Next: ${toLabel}. Change the sign, then press Continue.`;
      advanceOverlay.style.display = "flex";
    }

    function hideAdvanceOverlay() {
      advanceOverlay.style.display = "none";
      pendingAdvance = null;
    }

    advanceStayBtn.addEventListener("click", () => {
      hideAdvanceOverlay();
    });

    advanceContinueBtn.addEventListener("click", () => {
      if (!pendingAdvance) return;
      recLabelIndex = Math.min(LABELS.length - 1, recLabelIndex + 1);
      recStableSince = 0;
      recPrevVec = null;
      hideAdvanceOverlay();
      updateRecorderHeader();

      // Auto-resume recording
      recIsRunning = true;
      recStartBtn.disabled = true; recStopBtn.disabled = false;
      updateRecorderHeader();
    });

    function maybeAutoAdvanceIfDone() {
      const label = getRecTargetLabel();
      const goal = Math.max(5, Math.min(200, parseInt(recGoalEl.value || "30", 10)));
      const counts = getDatasetCountsFromKnn();
      const n = counts[label] || 0;

      if (n >= goal && recLabelIndex < LABELS.length - 1) {
        // STOP & CONFIRM
        if (recIsRunning) {
          recIsRunning = false;
          recStartBtn.disabled = false; recStopBtn.disabled = true;
          updateRecorderHeader();
        }
        const nextLabel = LABELS[recLabelIndex + 1];
        showAdvanceOverlay(label, nextLabel);
      }
    }

    function addRecorderSample(label, lm) {
      const vec = landmarksToNormalizedVector(lm);
      const tensor = tf.tensor(vec, [1, vec.length]);
      knn.addExample(tensor, label);
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();
      persistActiveProfileDataset();
      updateRecorderHeader();
    }

    function resetCurrentLetterSamples() {
      const label = getRecTargetLabel();
      const ds = knn.getClassifierDataset();
      if (!ds[label]) return;
      const newDS = {};
      for (const k of Object.keys(ds)) {
        if (k !== label) newDS[k] = ds[k];
      }
      knn.clearAllClasses();
      knn.setClassifierDataset(newDS);
      persistActiveProfileDataset();
      updateRecorderHeader();
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();
    }

    // Recorder step:
    // - predict label+conf
    // - if label==target && conf>=minConf held for holdMs, then add sample
    async function recorderStep() {
      if (!handLandmarker) return;
      const now = performance.now();
      const result = handLandmarker.detectForVideo(videoRec, now);
      drawHandsOn(videoRec, canvasRec, ctxRec, result);

      const lms = result.landmarks || [];
      if (lms.length === 0) {
        lastRecDominantLandmarks = null;
        recRawLabelEl.textContent = "—";
        recConfEl.textContent = "—";
        recStableSince = 0;
        recPrevVec = null;
        rafRec = requestAnimationFrame(recorderStep);
        return;
      }

      const idx = pickDominantHandIndex(result);
      lastRecDominantLandmarks = lms[idx];

      const pred = await knnPredict(lastRecDominantLandmarks);
      const label = pred.label || "NO SAMPLES";
      const conf = pred.conf || 0;

      recRawLabelEl.textContent = label;
      recConfEl.textContent = pred.label ? conf.toFixed(2) : "—";

      if (recIsRunning && pred.label) {
        const target = getRecTargetLabel();
        const minC = Math.max(0, Math.min(1, parseFloat(recMinConfEl.value || "0.70")));
        const holdMs = Math.max(100, Math.min(3000, parseInt(recHoldMsEl.value || "450", 10)));
        const cooldownMs = Math.max(50, Math.min(3000, parseInt(recCooldownMsEl.value || "220", 10)));
        const nowMs = Date.now();

        // Use vector stability (optional) to reduce jitter duplicates
        const vec = landmarksToNormalizedVector(lastRecDominantLandmarks);
        let vecDelta = 0;
        if (recPrevVec) {
          for (let i = 0; i < vec.length; i++) {
            const d = vec[i] - recPrevVec[i];
            vecDelta += d*d;
          }
          vecDelta = Math.sqrt(vecDelta);
        }
        recPrevVec = vec;

        const isGood = (label === target) && (conf >= minC);

        if (!isGood) {
          recStableSince = 0;
        } else {
          if (!recStableSince) recStableSince = nowMs;
          const held = nowMs - recStableSince;

          // sample only if held stable enough and cooldown passed
          if (held >= holdMs && (nowMs - recLastSampleAt) >= cooldownMs) {
            addRecorderSample(target, lastRecDominantLandmarks);
            recLastSampleAt = nowMs;
            recStableSince = 0; // require re-hold for next sample
            maybeAutoAdvanceIfDone();
          }
        }
      }

      rafRec = requestAnimationFrame(recorderStep);
    }

    async function recorderStart() {
      if (rafRec) return;
      const active = getActiveProfileName();
      const profiles = loadProfiles();
      if (profiles[active]?.mode !== "recording") {
        alert("Active profile is not in Recording mode. Switch profile or change mode in Profiles.");
        return;
      }

      setStatus("Starting…");
      if (!handLandmarker) await initHandLandmarker();

      streamRec = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
      videoRec.srcObject = streamRec;
      await videoRec.play();

      recIsRunning = true;
      recStartBtn.disabled = true;
      recStopBtn.disabled = false;
      updateRecorderHeader();

      setStatus("Running");
      rafRec = requestAnimationFrame(recorderStep);
    }

    function recorderStop() {
      recIsRunning = false;
      if (rafRec) cancelAnimationFrame(rafRec);
      rafRec = null;
      if (streamRec) { streamRec.getTracks().forEach(t => t.stop()); streamRec = null; }
      videoRec.srcObject = null;

      recStartBtn.disabled = false;
      recStopBtn.disabled = true;
      recStableSince = 0;
      recPrevVec = null;
      recRawLabelEl.textContent = "—";
      recConfEl.textContent = "—";
      updateRecorderHeader();

      setStatus("Idle");
    }

    recStartBtn.addEventListener("click", () => recorderStart().catch(err => {
      console.error(err);
      setStatus("Error");
      alert("Could not start Recorder. Run via http://localhost:8000 and allow camera.");
      recorderStop();
    }));
    recStopBtn.addEventListener("click", recorderStop);

    recPrevBtn.addEventListener("click", () => {
      recLabelIndex = Math.max(0, recLabelIndex - 1);
      recStableSince = 0; recPrevVec = null;
      updateRecorderHeader();
    });
    recNextBtn.addEventListener("click", () => {
      recLabelIndex = Math.min(LABELS.length - 1, recLabelIndex + 1);
      recStableSince = 0; recPrevVec = null;
      updateRecorderHeader();
    });

    recResetLetterBtn.addEventListener("click", () => {
      const label = getRecTargetLabel();
      if (!confirm(`Reset samples for letter "${label}" in active profile?`)) return;
      resetCurrentLetterSamples();
    });

    // Recorder export/import profile JSON
    recExportBtn.addEventListener("click", () => {
      persistActiveProfileDataset();
      const active = getActiveProfileName();
      const profiles = loadProfiles();
      const prof = profiles[active];
      downloadJSON(`${active || "profile"}_knn.json`, {
        profile: active,
        mode: prof?.mode || "recording",
        dataset: prof?.datasetJSON || datasetToJSON(knn.getClassifierDataset()),
        exportedAt: new Date().toISOString()
      });
    });

    recImportInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      const obj = JSON.parse(text);
      const dsObj = obj.dataset ? obj.dataset : obj;

      try {
        const ds = jsonToDataset(dsObj);
        knn.clearAllClasses();
        knn.setClassifierDataset(ds);
        persistActiveProfileDataset();
        sampleCountEl.textContent = knn.getNumExamples();
        activeSamplesKpi.textContent = knn.getNumExamples();
        updateRecorderHeader();
        alert("Imported into active profile.");
      } catch (err) {
        console.error(err);
        alert("Import failed. File format not recognized.");
      }
      recImportInput.value = "";
    });

    // -----------------------------
    // Profiles UI actions
    // -----------------------------
    profileCreateBtn.addEventListener("click", () => {
      const name = newProfileName.value;
      const mode = newProfileMode.value;
      const res = createProfile(name, mode);
      if (!res.ok) { alert(res.msg); return; }
      refreshProfileUI();
      newProfileName.value = "";
      alert("Profile created.");
    });

    profileActivateBtn.addEventListener("click", () => {
      const sel = profileSelect.value;
      if (!sel) return;
      setActiveProfile(sel);
    });

    profileDeleteBtn.addEventListener("click", () => {
      const sel = profileSelect.value;
      if (!sel) return;
      if (!confirm(`Delete profile "${sel}"? This cannot be undone.`)) return;
      deleteProfile(sel);
    });

    // Modal open/close
    switchProfileBtn.addEventListener("click", () => {
      refreshProfileUI();
      profileModal.style.display = "flex";
    });

    profileModalCloseBtn.addEventListener("click", () => {
      profileModal.style.display = "none";
    });

    profileModalActivateBtn.addEventListener("click", () => {
      const sel = profileModalSelect.value;
      if (!sel) return;
      profileModal.style.display = "none";
      setActiveProfile(sel);
    });

    profileModalCreateBtn.addEventListener("click", () => {
      const name = profileModalNewName.value;
      const mode = profileModalNewMode.value;
      const res = createProfile(name, mode);
      if (!res.ok) { alert(res.msg); return; }
      profileModal.style.display = "none";
      setActiveProfile(name.trim());
      profileModalNewName.value = "";
    });

    // -----------------------------
    // Persist dataset on unload
    // -----------------------------
    window.addEventListener("beforeunload", () => {
      try { persistActiveProfileDataset(); } catch {}
    });

    // -----------------------------
    // Boot
    // -----------------------------
    ensureDefaultProfiles();
    refreshProfileUI();
    setActiveProfile(getActiveProfileName());

    // Initial UI
    sampleCountEl.textContent = knn.getNumExamples();
    updateRecorderHeader();

    // Default tab based on mode
    const profs = loadProfiles();
    const active = getActiveProfileName();
    const mode = profs[active]?.mode || "demo";
    setActiveTab(mode === "recording" ? "recorder" : "demo");
  </script>
</body>
</html>
