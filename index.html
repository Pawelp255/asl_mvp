<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ASL MVP (Profiles + Recorder + Avatar 2D)</title>
  <style>
    :root { --bg:#fff; --fg:#111; --muted:#555; --border:#ddd; --soft:#fafafa; --danger:#b00020; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; color:var(--fg); background:var(--bg); }
    h1 { margin: 0 0 8px 0; }
    .muted { color: var(--muted); }
    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .panel { border:1px solid var(--border); border-radius:12px; padding:12px; background:#fff; flex: 1 1 520px; min-width: 300px; }
    video, canvas { width: 520px; max-width:100%; border-radius:12px; background:#000; }
    .big { font-size: 22px; font-weight: 800; }
    button, select, input { padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    button:active { transform: translateY(1px); }
    textarea { width:520px; max-width:100%; height:120px; border-radius:12px; padding:10px; border:1px solid var(--border); }
    .badge { display:inline-block; padding: 4px 10px; border-radius:999px; border:1px solid var(--border); background:var(--soft); }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
    .hr { height:1px; background:#eee; margin:10px 0; }
    label.small { font-size:12px; color: var(--muted); display:block; margin: 0 0 6px 0; }
    .inline { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin: 12px 0; }
    .tabBtn { padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:var(--soft); }
    .tabBtn.active { background:#111; color:#fff; border-color:#111; }
    .hide { display:none !important; }

    @media (min-width: 1100px) {
      .row { flex-wrap: nowrap; }
      .panel { flex: 0 0 calc(50% - 8px); }
    }

    .modalOverlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 18px;
    }
    .modal {
      width: min(580px, 100%);
      background: #fff;
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.3);
    }
    .modalTitle { font-weight:900; font-size:18px; margin-bottom:6px; }
    .modalActions { display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }
    .btnPrimary { background:#111; color:#fff; border-color:#111; }
    .btnGhost { background:#fff; }
    .btnDanger { background: var(--danger); color:#fff; border-color: var(--danger); }
    .kpi { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .kpi .badge { background:#f6f6f6; }

    /* Avatar 2D UI */
    .avatarCanvas { width: 520px; max-width: 100%; height: auto; border-radius: 12px; border:1px solid var(--border); background:#0b0b0b; }
    .hint { font-size:12px; color: var(--muted); }
  </style>
</head>
<body>
  <h1>ASL MVP (Local Profiles + Recorder + Avatar 2D)</h1>
  <div class="muted">
    Local inference (no cloud). MediaPipe HandLandmarker + TF.js kNN for Demo.
    Recorder uses <b>stability-based auto-capture</b>. New: <b>Avatar 2D</b> plays a sign sequence from text (fast to test).
  </div>

  <div class="tabs">
    <button class="tabBtn active" id="tabDemoBtn">Demo</button>
    <button class="tabBtn" id="tabRecorderBtn">Recorder</button>
    <button class="tabBtn" id="tabProfilesBtn">Profiles</button>
    <button class="tabBtn" id="tabAvatarBtn">Avatar</button>
  </div>

  <div class="inline" style="margin: 6px 0 14px 0;">
    <span class="badge">Active profile: <b id="activeProfileName">—</b></span>
    <span class="badge">Mode: <b id="activeProfileMode">—</b></span>
    <button id="switchProfileBtn">Switch / Create Profile</button>
    <a href="./avatar.html" class="tabBtn" style="text-decoration:none; display:inline-flex; align-items:center;">
  Avatar Dictionary
</a>

    <span class="badge" id="status">Idle</span>
  </div>

  <!-- DEMO TAB -->
  <div id="tabDemo">
    <div class="row">
      <div class="panel">
        <div class="muted">Camera</div>
        <video id="video" playsinline autoplay muted></video>

        <div class="inline" style="margin-top:10px;">
          <button id="startBtn">Start</button>
          <button id="stopBtn" disabled>Stop</button>
          <button id="clearTextBtn">Clear text</button>
        </div>

        <div class="hr"></div>

        <div class="grid">
          <div>
            <label class="small">Stabilization window (frames)</label>
            <input id="stabWindow" type="number" min="3" max="30" value="12" />
          </div>
          <div>
            <label class="small">Required majority (0.50–0.95)</label>
            <input id="stabMajority" type="number" step="0.05" min="0.5" max="0.95" value="0.7" />
          </div>
          <div>
            <label class="small">Min confidence (0–1)</label>
            <input id="minConf" type="number" step="0.05" min="0" max="1" value="0.55" />
          </div>
          <div>
            <label class="small">Emit debounce (ms)</label>
            <input id="emitDebounce" type="number" min="150" max="4000" value="900" />
          </div>
        </div>

        <div class="hr"></div>
        <div class="mono">Demo: kNN recognition + stabilization + debounce. Use for testing/presentation.</div>
      </div>

      <div class="panel">
        <div class="muted">Live View + Output</div>
        <canvas id="canvas"></canvas>

        <div style="margin-top:10px;">
          <div class="big">Stable: <span id="stableLabel">—</span></div>
          <div class="big">Raw: <span id="rawLabel">—</span></div>
          <div class="muted">Confidence: <span id="conf">—</span> | Hand used: <span id="handInfo">—</span></div>
        </div>

        <div class="hr"></div>

        <div class="inline">
          <label class="small" style="margin:0;">ASL label (train):</label>
          <select id="aslLabel">
            <option value="A">A</option><option value="B">B</option><option value="C">C</option><option value="D">D</option><option value="E">E</option>
            <option value="F">F</option><option value="G">G</option><option value="H">H</option><option value="I">I</option>
            <option value="K">K</option><option value="L">L</option><option value="M">M</option><option value="N">N</option><option value="O">O</option>
            <option value="P">P</option><option value="Q">Q</option><option value="R">R</option><option value="S">S</option><option value="T">T</option>
            <option value="U">U</option><option value="V">V</option><option value="W">W</option><option value="X">X</option><option value="Y">Y</option>
            <option value="SPACE">SPACE</option>
            <option value="BACKSPACE">BACKSPACE</option>
          </select>

          <button id="addSampleBtn">Add sample</button>
          <button id="clearSamplesBtn">Clear samples</button>
          <span class="badge">Samples: <span id="sampleCount">0</span></span>
        </div>

        <div class="inline" style="margin-top:10px;">
          <button id="exportBtn">Export JSON</button>
          <label class="badge" style="cursor:pointer;">
            Import JSON
            <input id="importInput" type="file" accept="application/json" style="display:none;">
          </label>
        </div>

        <div class="hr"></div>

        <div class="muted">Transcript</div>
        <textarea id="transcript" placeholder="Letters will appear here..."></textarea>

        <div class="inline" style="margin-top:10px;">
          <button id="sendTranscriptToAvatarBtn">Send transcript → Avatar</button>
          <span class="hint">Tip: Use SPACE / BACKSPACE too.</span>
        </div>

        <div class="mono" style="margin-top:8px;">
          Notes: Detects up to 2 hands; classification uses the largest hand (dominant by bbox area).
        </div>
      </div>
    </div>
  </div>

  <!-- RECORDER TAB -->
  <div id="tabRecorder" class="hide">
    <div class="row">
      <div class="panel">
        <div class="muted">Recorder Camera</div>
        <video id="videoRec" playsinline autoplay muted></video>

        <div class="inline" style="margin-top:10px;">
          <button id="recStartBtn">Start recorder</button>
          <button id="recStopBtn" disabled>Stop</button>
          <button id="recResetLetterBtn">Reset current letter</button>
        </div>

        <div class="hr"></div>
        <div class="kpi">
          <span class="badge">Target: <b id="recTargetLabel">—</b></span>
          <span class="badge">Progress: <b id="recProgress">0/30</b></span>
          <span class="badge">Recorder: <b id="recAutoState">OFF</b></span>
          <span class="badge">Motion: <b id="recMotion">—</b></span>
        </div>

        <div class="inline" style="margin-top:10px;">
          <label class="badge" style="cursor:pointer;">
            <input id="recCaptureEnabled" type="checkbox" checked style="margin-right:8px;">
            Capture enabled
          </label>
          <span class="badge">Test raw: <b id="recTestRaw">—</b></span>
          <span class="badge">Test stable: <b id="recTestStable">—</b></span>
          <span class="badge">Conf: <b id="recTestConf">—</b></span>
        </div>

        <div class="hr"></div>

        <div class="inline" style="margin-top:2px;">
          <label class="small" style="margin:0;">Preset</label>
          <select id="recPreset">
            <option value="fast">Fast</option>
            <option value="normal" selected>Normal</option>
            <option value="strict">Strict</option>
          </select>
        </div>

        <div class="grid" style="margin-top:10px;">
          <div>
            <label class="small">Goal per letter</label>
            <input id="recGoal" type="number" min="5" max="200" value="30" />
          </div>
          <div>
            <label class="small">Hold stable (ms)</label>
            <input id="recHoldMs" type="number" min="100" max="3000" value="450" />
          </div>
          <div>
            <label class="small">Cooldown between samples (ms)</label>
            <input id="recCooldownMs" type="number" min="50" max="3000" value="220" />
          </div>
          <div>
            <label class="small">Stability threshold</label>
            <input id="recStabThresh" type="number" step="0.01" min="0.01" max="0.50" value="0.08" />
          </div>
        </div>

        <div class="hr"></div>
        <div class="mono">
          Recorder: when Capture enabled is ON, it auto-adds samples for the selected target letter.
          When OFF, it runs <b>test-only</b> preview (raw/stable/conf) and does NOT add samples.
        </div>
      </div>

      <div class="panel">
        <div class="muted">Recorder Live View</div>
        <canvas id="canvasRec"></canvas>

        <div class="hr"></div>

        <div class="inline">
          <button id="recPrevBtn">Prev</button>
          <button id="recNextBtn">Next</button>
          <span class="badge">Letters: A–Y (no J/Z)</span>
        </div>

        <div class="hr"></div>

        <div class="inline">
          <button id="recExportBtn">Export profile JSON</button>
          <label class="badge" style="cursor:pointer;">
            Import into profile
            <input id="recImportInput" type="file" accept="application/json" style="display:none;">
          </label>
        </div>

        <div class="mono" style="margin-top:8px;">
          Tip: Keep Friend profile in Recording mode. Use Boss profile in Demo mode.
        </div>
      </div>
    </div>
  </div>

  <!-- PROFILES TAB -->
  <div id="tabProfiles" class="hide">
    <div class="panel">
      <div class="muted">Profiles (LocalStorage)</div>
      <div class="hr"></div>

      <div class="inline">
        <label class="small" style="margin:0;">Select</label>
        <select id="profileSelect"></select>
        <button id="profileActivateBtn" class="btnPrimary">Activate</button>
        <button id="profileDeleteBtn" class="btnDanger">Delete</button>
      </div>

      <div class="hr"></div>

      <div class="grid">
        <div>
          <label class="small">New profile name</label>
          <input id="newProfileName" placeholder="e.g., FriendRecorder" />
        </div>
        <div>
          <label class="small">Mode</label>
          <select id="newProfileMode">
            <option value="recording">Recording</option>
            <option value="demo">Demo</option>
          </select>
        </div>
      </div>

      <div class="inline" style="margin-top:10px;">
        <button id="profileCreateBtn">Create profile</button>
        <span class="badge">Active samples: <span id="activeSamplesKpi">0</span></span>
      </div>

      <div class="hr"></div>

      <div class="mono">
        Profiles are per-device/per-browser. Move datasets via Export/Import JSON.
      </div>
    </div>
  </div>

  <!-- AVATAR TAB (2D) -->
  <div id="tabAvatar" class="hide">
    <div class="row">
      <div class="panel">
        <div class="muted">Avatar (2D) – Text → Sign Sequence</div>
        <div class="hr"></div>

        <div class="inline">
          <button id="avatarUseTranscriptBtn">Use transcript from Demo</button>
          <button id="avatarClearTextBtn">Clear</button>
          <span class="badge">Queue: <b id="avatarQueueKpi">0</b></span>
        </div>

        <div class="grid" style="margin-top:10px;">
          <div>
            <label class="small">Speed (ms per symbol)</label>
            <input id="avatarSpeedMs" type="number" min="120" max="2500" value="550" />
          </div>
          <div>
            <label class="small">Pause between words (ms)</label>
            <input id="avatarWordPauseMs" type="number" min="0" max="5000" value="500" />
          </div>
        </div>

        <div class="hr"></div>

        <label class="small">Text to play (A–Z, spaces)</label>
        <textarea id="avatarText" placeholder="Type text like: HELLO WORLD"></textarea>

        <div class="inline" style="margin-top:10px;">
          <button id="avatarPlayBtn" class="btnPrimary">Play</button>
          <button id="avatarPauseBtn" disabled>Pause</button>
          <button id="avatarStopBtn" disabled>Stop</button>
          <span class="badge">Now: <b id="avatarNow">—</b></span>
        </div>

        <div class="hr"></div>
        <div class="mono">
          This 2D avatar is a fast placeholder. It animates a “sign pose card” per letter.
          Next step (B): replace this with a real 3D humanoid (VRM) while keeping the same queue/player logic.
        </div>
      </div>

      <div class="panel">
        <div class="muted">Avatar View</div>
        <div class="hr"></div>
        <canvas id="avatarCanvas" class="avatarCanvas" width="920" height="520"></canvas>
        <div class="mono" style="margin-top:8px;">
          Pose coverage: special stylized drawings for A–E + SPACE. Other letters show a clean letter-card (still useful for timing/UX tests).
        </div>
      </div>
    </div>
  </div>

  <!-- Profile Switch Modal -->
  <div class="modalOverlay" id="profileModal">
    <div class="modal">
      <div class="modalTitle">Switch / Create Profile</div>
      <div class="muted">Mode decides intended workflow: Recording or Demo.</div>
      <div class="hr"></div>

      <div class="inline">
        <label class="small" style="margin:0;">Existing</label>
        <select id="profileModalSelect"></select>
        <button id="profileModalActivateBtn" class="btnPrimary">Activate</button>
      </div>

      <div class="hr"></div>

      <div class="grid">
        <div>
          <label class="small">New profile name</label>
          <input id="profileModalNewName" placeholder="e.g., BossDemo / FriendRecording" />
        </div>
        <div>
          <label class="small">Mode</label>
          <select id="profileModalNewMode">
            <option value="recording">Recording</option>
            <option value="demo">Demo</option>
          </select>
        </div>
      </div>

      <div class="inline" style="margin-top:10px; justify-content:flex-end;">
        <button id="profileModalCreateBtn">Create & Activate</button>
        <button id="profileModalCloseBtn" class="btnGhost">Close</button>
      </div>
    </div>
  </div>

  <!-- Recorder Advance Overlay -->
  <div class="modalOverlay" id="advanceOverlay">
    <div class="modal">
      <div class="modalTitle">Letter completed</div>
      <div class="muted" id="advanceMsg">—</div>
      <div class="hr"></div>
      <div class="modalActions">
        <button id="advanceStayBtn" class="btnGhost">Stay on current</button>
        <button id="advanceContinueBtn" class="btnPrimary">Continue</button>
      </div>
    </div>
  </div>

  <!-- TF.js + kNN -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2/dist/knn-classifier.min.js"></script>

  <script type="module">
    import { FilesetResolver, HandLandmarker, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    // -----------------------
    // Tabs
    // -----------------------
    const tabDemoBtn = document.getElementById("tabDemoBtn");
    const tabRecorderBtn = document.getElementById("tabRecorderBtn");
    const tabProfilesBtn = document.getElementById("tabProfilesBtn");
    const tabAvatarBtn = document.getElementById("tabAvatarBtn");

    const tabDemo = document.getElementById("tabDemo");
    const tabRecorder = document.getElementById("tabRecorder");
    const tabProfiles = document.getElementById("tabProfiles");
    const tabAvatar = document.getElementById("tabAvatar");

    function setActiveTab(name) {
      tabDemoBtn.classList.toggle("active", name === "demo");
      tabRecorderBtn.classList.toggle("active", name === "recorder");
      tabProfilesBtn.classList.toggle("active", name === "profiles");
      tabAvatarBtn.classList.toggle("active", name === "avatar");

      tabDemo.classList.toggle("hide", name !== "demo");
      tabRecorder.classList.toggle("hide", name !== "recorder");
      tabProfiles.classList.toggle("hide", name !== "profiles");
      tabAvatar.classList.toggle("hide", name !== "avatar");
    }

    tabDemoBtn.addEventListener("click", () => setActiveTab("demo"));
    tabRecorderBtn.addEventListener("click", () => setActiveTab("recorder"));
    tabProfilesBtn.addEventListener("click", () => setActiveTab("profiles"));
    tabAvatarBtn.addEventListener("click", () => setActiveTab("avatar"));

    // -----------------------
    // Top bar
    // -----------------------
    const activeProfileNameEl = document.getElementById("activeProfileName");
    const activeProfileModeEl = document.getElementById("activeProfileMode");
    const switchProfileBtn = document.getElementById("switchProfileBtn");
    const statusEl = document.getElementById("status");
    function setStatus(s) { statusEl.textContent = s; }

    // -----------------------
    // Demo refs
    // -----------------------
    const videoEl = document.getElementById("video");
    const canvasEl = document.getElementById("canvas");
    const ctx = canvasEl.getContext("2d");

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const clearTextBtn = document.getElementById("clearTextBtn");

    const stableLabelEl = document.getElementById("stableLabel");
    const rawLabelEl = document.getElementById("rawLabel");
    const confEl = document.getElementById("conf");
    const handInfoEl = document.getElementById("handInfo");

    const transcriptEl = document.getElementById("transcript");

    const aslLabelEl = document.getElementById("aslLabel");
    const addSampleBtn = document.getElementById("addSampleBtn");
    const clearSamplesBtn = document.getElementById("clearSamplesBtn");
    const sampleCountEl = document.getElementById("sampleCount");
    const exportBtn = document.getElementById("exportBtn");
    const importInput = document.getElementById("importInput");

    const stabWindowEl = document.getElementById("stabWindow");
    const stabMajorityEl = document.getElementById("stabMajority");
    const minConfEl = document.getElementById("minConf");
    const emitDebounceEl = document.getElementById("emitDebounce");

    const sendTranscriptToAvatarBtn = document.getElementById("sendTranscriptToAvatarBtn");

    // -----------------------
    // Recorder refs
    // -----------------------
    const videoRec = document.getElementById("videoRec");
    const canvasRec = document.getElementById("canvasRec");
    const ctxRec = canvasRec.getContext("2d");

    const recStartBtn = document.getElementById("recStartBtn");
    const recStopBtn = document.getElementById("recStopBtn");
    const recResetLetterBtn = document.getElementById("recResetLetterBtn");

    const recTargetLabelEl = document.getElementById("recTargetLabel");
    const recProgressEl = document.getElementById("recProgress");
    const recAutoStateEl = document.getElementById("recAutoState");
    const recMotionEl = document.getElementById("recMotion");

    const recPresetEl = document.getElementById("recPreset");
    const recGoalEl = document.getElementById("recGoal");
    const recHoldMsEl = document.getElementById("recHoldMs");
    const recCooldownMsEl = document.getElementById("recCooldownMs");
    const recStabThreshEl = document.getElementById("recStabThresh");

    const recPrevBtn = document.getElementById("recPrevBtn");
    const recNextBtn = document.getElementById("recNextBtn");

    const recExportBtn = document.getElementById("recExportBtn");
    const recImportInput = document.getElementById("recImportInput");

    const recCaptureEnabledEl = document.getElementById("recCaptureEnabled");
    const recTestRawEl = document.getElementById("recTestRaw");
    const recTestStableEl = document.getElementById("recTestStable");
    const recTestConfEl = document.getElementById("recTestConf");

    // Advance overlay
    const advanceOverlay = document.getElementById("advanceOverlay");
    const advanceMsg = document.getElementById("advanceMsg");
    const advanceStayBtn = document.getElementById("advanceStayBtn");
    const advanceContinueBtn = document.getElementById("advanceContinueBtn");

    // Profiles tab
    const profileSelect = document.getElementById("profileSelect");
    const profileActivateBtn = document.getElementById("profileActivateBtn");
    const profileDeleteBtn = document.getElementById("profileDeleteBtn");
    const newProfileName = document.getElementById("newProfileName");
    const newProfileMode = document.getElementById("newProfileMode");
    const profileCreateBtn = document.getElementById("profileCreateBtn");
    const activeSamplesKpi = document.getElementById("activeSamplesKpi");

    // Profile modal
    const profileModal = document.getElementById("profileModal");
    const profileModalSelect = document.getElementById("profileModalSelect");
    const profileModalActivateBtn = document.getElementById("profileModalActivateBtn");
    const profileModalNewName = document.getElementById("profileModalNewName");
    const profileModalNewMode = document.getElementById("profileModalNewMode");
    const profileModalCreateBtn = document.getElementById("profileModalCreateBtn");
    const profileModalCloseBtn = document.getElementById("profileModalCloseBtn");

    // -----------------------
    // Avatar 2D refs
    // -----------------------
    const avatarTextEl = document.getElementById("avatarText");
    const avatarCanvas = document.getElementById("avatarCanvas");
    const avatarCtx = avatarCanvas.getContext("2d");
    const avatarPlayBtn = document.getElementById("avatarPlayBtn");
    const avatarPauseBtn = document.getElementById("avatarPauseBtn");
    const avatarStopBtn = document.getElementById("avatarStopBtn");
    const avatarNowEl = document.getElementById("avatarNow");
    const avatarSpeedMsEl = document.getElementById("avatarSpeedMs");
    const avatarWordPauseMsEl = document.getElementById("avatarWordPauseMs");
    const avatarUseTranscriptBtn = document.getElementById("avatarUseTranscriptBtn");
    const avatarClearTextBtn = document.getElementById("avatarClearTextBtn");
    const avatarQueueKpi = document.getElementById("avatarQueueKpi");

    // -----------------------
    // kNN
    // -----------------------
    const knn = knnClassifier.create();

    // -----------------------
    // MediaPipe
    // -----------------------
    let handLandmarker = null;
    let drawingDemo = null;
    let drawingRec = null;

    let streamDemo = null;
    let rafDemo = null;
    let lastDominantLandmarks = null;

    let streamRec = null;
    let rafRec = null;
    let lastRecDominantLandmarks = null;

    // -----------------------
    // Profiles (LocalStorage)
    // -----------------------
    const LS_KEY = "asl_profiles_v2";
    const LS_ACTIVE = "asl_active_profile_v2";

    function loadProfiles() {
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
      catch { return {}; }
    }
    function saveProfiles(p) { localStorage.setItem(LS_KEY, JSON.stringify(p)); }
    function getActiveProfileName() { return localStorage.getItem(LS_ACTIVE) || ""; }

    function datasetToJSON(dataset) {
      const out = {};
      for (const label of Object.keys(dataset)) {
        const t = dataset[label];
        out[label] = { shape: t.shape, data: Array.from(t.dataSync()) };
      }
      return out;
    }
    function jsonToDataset(obj) {
      const ds = {};
      for (const label of Object.keys(obj)) {
        const { shape, data } = obj[label];
        ds[label] = tf.tensor(data, shape);
      }
      return ds;
    }

    function persistActiveProfileDataset() {
      const name = getActiveProfileName();
      if (!name) return;
      const profiles = loadProfiles();
      if (!profiles[name]) return;
      profiles[name].datasetJSON = datasetToJSON(knn.getClassifierDataset());
      profiles[name].updatedAt = Date.now();
      saveProfiles(profiles);
    }

    function refreshProfileUI() {
      const profiles = loadProfiles();
      const names = Object.keys(profiles).sort((a,b)=>a.localeCompare(b));
      const active = getActiveProfileName();

      function fillSelect(sel) {
        sel.innerHTML = "";
        for (const n of names) {
          const opt = document.createElement("option");
          opt.value = n;
          opt.textContent = `${n} (${profiles[n].mode})`;
          if (n === active) opt.selected = true;
          sel.appendChild(opt);
        }
      }
      fillSelect(profileSelect);
      fillSelect(profileModalSelect);

      if (profiles[active]) {
        activeProfileNameEl.textContent = active;
        activeProfileModeEl.textContent = profiles[active].mode;
      } else {
        activeProfileNameEl.textContent = "—";
        activeProfileModeEl.textContent = "—";
      }

      activeSamplesKpi.textContent = knn.getNumExamples();
    }

    function ensureDefaultProfiles() {
      const p = loadProfiles();
      const keys = Object.keys(p);
      if (keys.length === 0) {
        p["BossDemo"] = { mode: "demo", datasetJSON: null, createdAt: Date.now() };
        p["FriendRecording"] = { mode: "recording", datasetJSON: null, createdAt: Date.now() };
        saveProfiles(p);
        localStorage.setItem(LS_ACTIVE, "BossDemo");
      } else if (!localStorage.getItem(LS_ACTIVE)) {
        localStorage.setItem(LS_ACTIVE, keys[0]);
      }
    }

    function setActiveProfile(name) {
      const profiles = loadProfiles();
      if (!profiles[name]) return;

      persistActiveProfileDataset();

      localStorage.setItem(LS_ACTIVE, name);

      knn.clearAllClasses();
      if (profiles[name].datasetJSON) {
        try { knn.setClassifierDataset(jsonToDataset(profiles[name].datasetJSON)); }
        catch (e) { console.warn("Failed to load dataset for profile", name, e); }
      }

      refreshProfileUI();
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();

      if (profiles[name].mode === "recording") setActiveTab("recorder");
      else setActiveTab("demo");

      updateRecorderHeader();
      setStatus("Idle");
    }

    function createProfile(name, mode) {
      name = (name || "").trim();
      if (!name) return { ok:false, msg:"Profile name is required." };
      const profiles = loadProfiles();
      if (profiles[name]) return { ok:false, msg:"Profile already exists." };
      profiles[name] = { mode, datasetJSON: null, createdAt: Date.now() };
      saveProfiles(profiles);
      return { ok:true };
    }

    function deleteProfile(name) {
      const profiles = loadProfiles();
      if (!profiles[name]) return;
      delete profiles[name];
      saveProfiles(profiles);
      const remaining = Object.keys(profiles);
      if (getActiveProfileName() === name) localStorage.setItem(LS_ACTIVE, remaining[0] || "");
      refreshProfileUI();
      const a = getActiveProfileName();
      if (a) setActiveProfile(a);
    }

    // -----------------------
    // Utilities
    // -----------------------
    function downloadJSON(filename, obj) {
      const blob = new Blob([JSON.stringify(obj)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function ensureCanvasSizeFor(video, canvas) {
      const w = video.videoWidth || 640;
      const h = video.videoHeight || 480;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
    }

    function landmarksToNormalizedVector(lm) {
      const base = lm[0];
      const dx1 = lm[5].x - base.x, dy1 = lm[5].y - base.y, dz1 = (lm[5].z ?? 0) - (base.z ?? 0);
      const dx2 = lm[9].x - base.x, dy2 = lm[9].y - base.y, dz2 = (lm[9].z ?? 0) - (base.z ?? 0);
      const s1 = Math.hypot(dx1, dy1, dz1);
      const s2 = Math.hypot(dx2, dy2, dz2);
      const scale = Math.max(1e-6, (s1 + s2) / 2);

      const v = [];
      for (const p of lm) {
        v.push((p.x - base.x) / scale);
        v.push((p.y - base.y) / scale);
        v.push(((p.z ?? 0) - (base.z ?? 0)) / scale);
      }

      let norm = 0;
      for (const x of v) norm += x * x;
      norm = Math.sqrt(Math.max(1e-12, norm));
      for (let i = 0; i < v.length; i++) v[i] /= norm;

      return v;
    }

    function bboxAreaFromLandmarks(lm) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of lm) {
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
      }
      const w = Math.max(0, maxX - minX);
      const h = Math.max(0, maxY - minY);
      return w * h;
    }
    function pickDominantHandIndex(result) {
      const lms = result.landmarks || [];
      if (lms.length === 0) return -1;
      if (lms.length === 1) return 0;
      let bestIdx = 0, bestArea = -1;
      for (let i = 0; i < lms.length; i++) {
        const area = bboxAreaFromLandmarks(lms[i]);
        if (area > bestArea) { bestArea = area; bestIdx = i; }
      }
      return bestIdx;
    }
    function handednessLabel(result, idx) {
      try {
        const h = result.handedness?.[idx]?.[0];
        if (!h) return null;
        return `${h.categoryName} (${(h.score ?? 0).toFixed(2)})`;
      } catch { return null; }
    }

    // -----------------------
    // MediaPipe init
    // -----------------------
    async function initHandLandmarker() {
      setStatus("Loading model…");
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
        },
        runningMode: "VIDEO",
        numHands: 2
      });
      drawingDemo = new DrawingUtils(ctx);
      drawingRec = new DrawingUtils(ctxRec);
    }

    function drawHands(video, canvas, context, drawing, result) {
      ensureCanvasSizeFor(video, canvas);
      context.save();
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      const lms = result.landmarks || [];
      if (lms.length > 0) {
        for (const lm of lms) {
          drawing.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 3 });
          drawing.drawLandmarks(lm, { lineWidth: 2 });
        }
      }
      context.restore();
    }

    // -----------------------
    // kNN predict
    // -----------------------
    async function knnPredict(lm) {
      if (knn.getNumExamples() <= 0) return { label: null, conf: 0 };
      const vec = landmarksToNormalizedVector(lm);
      const tensor = tf.tensor(vec, [1, vec.length]);
      const pred = await knn.predictClass(tensor, 5);
      tensor.dispose?.();
      const label = pred.label;
      const conf = (pred.confidences && pred.confidences[label]) ? pred.confidences[label] : 0;
      return { label, conf };
    }

    // -----------------------
    // Demo stabilization
    // -----------------------
    let predHistory = [];
    let lastEmitted = { label: null, t: 0 };

    function addPrediction(label, conf) {
      const windowN = Math.max(3, Math.min(30, parseInt(stabWindowEl.value || "12", 10)));
      predHistory.push({ label, conf, t: Date.now() });
      if (predHistory.length > windowN) predHistory.shift();
    }
    function getStablePrediction() {
      if (predHistory.length === 0) return { label: null, conf: 0, ratio: 0 };

      const minConf = Math.max(0, Math.min(1, parseFloat(minConfEl.value || "0.55")));
      const majority = Math.max(0.5, Math.min(0.95, parseFloat(stabMajorityEl.value || "0.7")));

      const counts = new Map();
      const confSum = new Map();
      let considered = 0;

      for (const p of predHistory) {
        if (p.conf < minConf) continue;
        considered++;
        counts.set(p.label, (counts.get(p.label) || 0) + 1);
        confSum.set(p.label, (confSum.get(p.label) || 0) + p.conf);
      }
      if (considered === 0) return { label: null, conf: 0, ratio: 0 };

      let bestLabel = null, bestCount = -1, bestAvgConf = -1;
      for (const [label, c] of counts.entries()) {
        const avg = (confSum.get(label) || 0) / c;
        if (c > bestCount || (c === bestCount && avg > bestAvgConf)) {
          bestLabel = label; bestCount = c; bestAvgConf = avg;
        }
      }
      const ratio = bestCount / considered;
      if (ratio >= majority) return { label: bestLabel, conf: bestAvgConf, ratio };
      return { label: null, conf: bestAvgConf, ratio };
    }

    function emitIfStable(label) {
      if (!label) return;
      const now = Date.now();
      const debounceMs = Math.max(150, Math.min(4000, parseInt(emitDebounceEl.value || "900", 10)));
      if (lastEmitted.label === label && (now - lastEmitted.t) < (debounceMs + 250)) return;
      if ((now - lastEmitted.t) < debounceMs) return;

      if (label === "BACKSPACE") transcriptEl.value = transcriptEl.value.slice(0, -1);
      else if (label === "SPACE") transcriptEl.value += " ";
      else transcriptEl.value += label;

      lastEmitted = { label, t: now };
    }

    // -----------------------
    // Demo loop
    // -----------------------
    async function demoStep() {
      if (!handLandmarker) return;
      const now = performance.now();
      const result = handLandmarker.detectForVideo(videoEl, now);
      drawHands(videoEl, canvasEl, ctx, drawingDemo, result);

      const lms = result.landmarks || [];
      if (lms.length === 0) {
        lastDominantLandmarks = null;
        predHistory = [];
        rawLabelEl.textContent = "—";
        stableLabelEl.textContent = "—";
        confEl.textContent = "—";
        handInfoEl.textContent = "—";
      } else {
        const idx = pickDominantHandIndex(result);
        lastDominantLandmarks = lms[idx];
        handInfoEl.textContent = handednessLabel(result, idx) || `#${idx}`;

        const pred = await knnPredict(lastDominantLandmarks);
        if (!pred.label) {
          rawLabelEl.textContent = "NO SAMPLES";
          stableLabelEl.textContent = "Train first";
          confEl.textContent = "—";
        } else {
          rawLabelEl.textContent = pred.label;
          confEl.textContent = pred.conf.toFixed(2);
          addPrediction(pred.label, pred.conf);
          const stable = getStablePrediction();
          stableLabelEl.textContent = stable.label ? `${stable.label} (ratio ${stable.ratio.toFixed(2)})` : `— (ratio ${stable.ratio.toFixed(2)})`;
          emitIfStable(stable.label);
        }
      }
      rafDemo = requestAnimationFrame(demoStep);
    }

    async function demoStart() {
      if (rafDemo) return;
      setStatus("Starting…");
      if (!handLandmarker) await initHandLandmarker();
      streamDemo = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
      videoEl.srcObject = streamDemo;
      await videoEl.play();
      setStatus("Running");
      startBtn.disabled = true;
      stopBtn.disabled = false;
      rafDemo = requestAnimationFrame(demoStep);
    }

    function demoStop() {
      if (rafDemo) cancelAnimationFrame(rafDemo);
      rafDemo = null;
      if (streamDemo) { streamDemo.getTracks().forEach(t => t.stop()); streamDemo = null; }
      videoEl.srcObject = null;
      setStatus("Idle");
      startBtn.disabled = false;
      stopBtn.disabled = true;
      predHistory = [];
      lastEmitted = { label: null, t: 0 };
      lastDominantLandmarks = null;
      rawLabelEl.textContent = "—";
      stableLabelEl.textContent = "—";
      confEl.textContent = "—";
      handInfoEl.textContent = "—";
    }

    startBtn.addEventListener("click", () => demoStart().catch(err => {
      console.error(err);
      setStatus("Error");
      alert("Could not start. Use Chrome/Edge and run via http(s) (not file://). Check camera permissions.");
      demoStop();
    }));
    stopBtn.addEventListener("click", demoStop);

    clearTextBtn.addEventListener("click", () => {
      transcriptEl.value = "";
      predHistory = [];
      lastEmitted = { label: null, t: 0 };
    });

    addSampleBtn.addEventListener("click", () => {
      if (!lastDominantLandmarks) { alert("No hand detected. Show your hand to the camera first."); return; }
      const label = aslLabelEl.value;
      const vec = landmarksToNormalizedVector(lastDominantLandmarks);
      const tensor = tf.tensor(vec, [1, vec.length]);
      knn.addExample(tensor, label);
      tensor.dispose?.();
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();
      persistActiveProfileDataset();
    });

    clearSamplesBtn.addEventListener("click", () => {
      if (!confirm("Clear ALL samples for active profile?")) return;
      knn.clearAllClasses();
      sampleCountEl.textContent = 0;
      activeSamplesKpi.textContent = 0;
      predHistory = [];
      lastEmitted = { label: null, t: 0 };
      rawLabelEl.textContent = "—";
      stableLabelEl.textContent = "—";
      confEl.textContent = "—";
      persistActiveProfileDataset();
      updateRecorderHeader();
    });

    exportBtn.addEventListener("click", () => {
      persistActiveProfileDataset();
      const active = getActiveProfileName();
      const profiles = loadProfiles();
      const prof = profiles[active];
      downloadJSON(`${active || "profile"}_knn.json`, {
        profile: active,
        mode: prof?.mode || "demo",
        dataset: prof?.datasetJSON || datasetToJSON(knn.getClassifierDataset()),
        exportedAt: new Date().toISOString()
      });
    });

    importInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      const obj = JSON.parse(text);
      const dsObj = obj.dataset ? obj.dataset : obj;
      try {
        knn.clearAllClasses();
        knn.setClassifierDataset(jsonToDataset(dsObj));
        sampleCountEl.textContent = knn.getNumExamples();
        activeSamplesKpi.textContent = knn.getNumExamples();
        persistActiveProfileDataset();
        updateRecorderHeader();
        alert("Imported into active profile.");
      } catch (err) {
        console.error(err);
        alert("Import failed. File format not recognized.");
      }
      importInput.value = "";
    });

    // -----------------------
    // Recorder (stability-based) + Test-only preview
    // -----------------------
    const LABELS = ["A","B","C","D","E","F","G","H","I","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y"];
    let recLabelIndex = 0;
    let recIsRunning = false;
    let recLastSampleAt = 0;
    let recStableSince = 0;
    let recPrevVec = null;
    let pendingAdvance = null;

    let recPredHistory = [];
    function recAddPrediction(label, conf) {
      const windowN = 12;
      recPredHistory.push({ label, conf, t: Date.now() });
      if (recPredHistory.length > windowN) recPredHistory.shift();
    }
    function recGetStablePrediction() {
      if (recPredHistory.length === 0) return { label: null, conf: 0, ratio: 0 };
      const minConf = 0.55;
      const majority = 0.7;

      const counts = new Map();
      const confSum = new Map();
      let considered = 0;

      for (const p of recPredHistory) {
        if (p.conf < minConf) continue;
        considered++;
        counts.set(p.label, (counts.get(p.label) || 0) + 1);
        confSum.set(p.label, (confSum.get(p.label) || 0) + p.conf);
      }
      if (considered === 0) return { label: null, conf: 0, ratio: 0 };

      let bestLabel = null, bestCount = -1, bestAvg = -1;
      for (const [label, c] of counts.entries()) {
        const avg = (confSum.get(label) || 0) / c;
        if (c > bestCount || (c === bestCount && avg > bestAvg)) {
          bestLabel = label; bestCount = c; bestAvg = avg;
        }
      }
      const ratio = bestCount / considered;
      if (ratio >= majority) return { label: bestLabel, conf: bestAvg, ratio };
      return { label: null, conf: bestAvg, ratio };
    }

    function getRecTargetLabel() { return LABELS[recLabelIndex] || "A"; }

    function getDatasetCountsFromKnn() {
      const ds = knn.getClassifierDataset();
      const counts = {};
      for (const label of Object.keys(ds)) {
        const t = ds[label];
        counts[label] = t.shape?.[0] || 0;
      }
      return counts;
    }

    function updateRecorderHeader() {
      const label = getRecTargetLabel();
      recTargetLabelEl.textContent = label;
      const goal = Math.max(5, Math.min(200, parseInt(recGoalEl.value || "30", 10)));
      const counts = getDatasetCountsFromKnn();
      const n = counts[label] || 0;
      recProgressEl.textContent = `${n}/${goal}`;
      recAutoStateEl.textContent = recIsRunning ? "ON" : "OFF";
    }

    function applyRecPreset(p) {
      if (p === "fast") {
        recHoldMsEl.value = 250;
        recCooldownMsEl.value = 140;
        recStabThreshEl.value = 0.11;
      } else if (p === "strict") {
        recHoldMsEl.value = 650;
        recCooldownMsEl.value = 260;
        recStabThreshEl.value = 0.06;
      } else {
        recHoldMsEl.value = 450;
        recCooldownMsEl.value = 220;
        recStabThreshEl.value = 0.08;
      }
      updateRecorderHeader();
    }
    recPresetEl.addEventListener("change", () => applyRecPreset(recPresetEl.value));

    function showAdvanceOverlay(fromLabel, toLabel) {
      const goal = Math.max(5, Math.min(200, parseInt(recGoalEl.value || "30", 10)));
      pendingAdvance = { fromLabel, toLabel };
      advanceMsg.textContent = `${fromLabel} complete (${goal}/${goal}). Next: ${toLabel}. Change the sign, then press Continue.`;
      advanceOverlay.style.display = "flex";
    }
    function hideAdvanceOverlay() {
      advanceOverlay.style.display = "none";
      pendingAdvance = null;
    }
    advanceStayBtn.addEventListener("click", () => hideAdvanceOverlay());
    advanceContinueBtn.addEventListener("click", () => {
      if (!pendingAdvance) return;
      recLabelIndex = Math.min(LABELS.length - 1, recLabelIndex + 1);
      recStableSince = 0; recPrevVec = null;
      recPredHistory = [];
      recTestRawEl.textContent = "—";
      recTestStableEl.textContent = "—";
      recTestConfEl.textContent = "—";
      hideAdvanceOverlay();
      updateRecorderHeader();
      recIsRunning = true;
      recStartBtn.disabled = true; recStopBtn.disabled = false;
      updateRecorderHeader();
    });

    function maybeAutoAdvanceIfDone() {
      const label = getRecTargetLabel();
      const goal = Math.max(5, Math.min(200, parseInt(recGoalEl.value || "30", 10)));
      const counts = getDatasetCountsFromKnn();
      const n = counts[label] || 0;
      if (n >= goal && recLabelIndex < LABELS.length - 1) {
        if (recIsRunning) {
          recIsRunning = false;
          recStartBtn.disabled = false; recStopBtn.disabled = true;
          updateRecorderHeader();
        }
        const nextLabel = LABELS[recLabelIndex + 1];
        showAdvanceOverlay(label, nextLabel);
      }
    }

    function addRecorderSample(label, lm) {
      const vec = landmarksToNormalizedVector(lm);
      const tensor = tf.tensor(vec, [1, vec.length]);
      knn.addExample(tensor, label);
      tensor.dispose?.();
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();
      persistActiveProfileDataset();
      updateRecorderHeader();
    }

    function resetCurrentLetterSamples() {
      const label = getRecTargetLabel();
      const ds = knn.getClassifierDataset();
      if (!ds[label]) return;
      const newDS = {};
      for (const k of Object.keys(ds)) if (k !== label) newDS[k] = ds[k];
      knn.clearAllClasses();
      knn.setClassifierDataset(newDS);
      persistActiveProfileDataset();
      sampleCountEl.textContent = knn.getNumExamples();
      activeSamplesKpi.textContent = knn.getNumExamples();
      updateRecorderHeader();
    }

    let recLastFrameTs = 0;

    async function recorderStep(ts) {
      if (!handLandmarker) return;

      if (ts - recLastFrameTs < 66) {
        rafRec = requestAnimationFrame(recorderStep);
        return;
      }
      recLastFrameTs = ts;

      const result = handLandmarker.detectForVideo(videoRec, ts);
      drawHands(videoRec, canvasRec, ctxRec, drawingRec, result);

      const lms = result.landmarks || [];
      if (lms.length === 0) {
        lastRecDominantLandmarks = null;
        recStableSince = 0;
        recPrevVec = null;
        recMotionEl.textContent = "—";
        recPredHistory = [];
        recTestRawEl.textContent = "—";
        recTestStableEl.textContent = "—";
        recTestConfEl.textContent = "—";
        rafRec = requestAnimationFrame(recorderStep);
        return;
      }

      const idx = pickDominantHandIndex(result);
      lastRecDominantLandmarks = lms[idx];

      const vec = landmarksToNormalizedVector(lastRecDominantLandmarks);
      let vecDelta = 999;
      if (recPrevVec) {
        let sum = 0;
        for (let i = 0; i < vec.length; i++) {
          const d = vec[i] - recPrevVec[i];
          sum += d * d;
        }
        vecDelta = Math.sqrt(sum);
      }
      recPrevVec = vec;
      recMotionEl.textContent = isFinite(vecDelta) ? vecDelta.toFixed(3) : "—";

      // Test-only preview
      if (knn.getNumExamples() > 0) {
        const pred = await knnPredict(lastRecDominantLandmarks);
        if (pred.label) {
          recTestRawEl.textContent = pred.label;
          recTestConfEl.textContent = pred.conf.toFixed(2);
          recAddPrediction(pred.label, pred.conf);
          const stable = recGetStablePrediction();
          recTestStableEl.textContent = stable.label ? `${stable.label} (${stable.ratio.toFixed(2)})` : `— (${stable.ratio.toFixed(2)})`;
        } else {
          recTestRawEl.textContent = "NO SAMPLES";
          recTestStableEl.textContent = "—";
          recTestConfEl.textContent = "—";
        }
      } else {
        recTestRawEl.textContent = "NO SAMPLES";
        recTestStableEl.textContent = "—";
        recTestConfEl.textContent = "—";
      }

      // Capture branch
      if (recIsRunning && lastRecDominantLandmarks && recCaptureEnabledEl.checked) {
        const holdMs = Math.max(100, Math.min(3000, parseInt(recHoldMsEl.value || "450", 10)));
        const cooldownMs = Math.max(50, Math.min(3000, parseInt(recCooldownMsEl.value || "220", 10)));
        const stabThresh = Math.max(0.01, Math.min(0.50, parseFloat(recStabThreshEl.value || "0.08")));
        const nowMs = Date.now();

        const stableEnough = vecDelta <= stabThresh;

        if (!stableEnough) {
          recStableSince = 0;
        } else {
          if (!recStableSince) recStableSince = nowMs;
          const held = nowMs - recStableSince;
          if (held >= holdMs && (nowMs - recLastSampleAt) >= cooldownMs) {
            addRecorderSample(getRecTargetLabel(), lastRecDominantLandmarks);
            recLastSampleAt = nowMs;
            recStableSince = 0;
            maybeAutoAdvanceIfDone();
          }
        }
      }

      rafRec = requestAnimationFrame(recorderStep);
    }

    async function recorderStart() {
      if (rafRec) return;

      const profiles = loadProfiles();
      const active = getActiveProfileName();
      if (profiles[active]?.mode !== "recording") {
        alert("Active profile is not in Recording mode. Switch profile or set mode in Profiles.");
        return;
      }

      setStatus("Starting…");
      if (!handLandmarker) await initHandLandmarker();

      streamRec = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
      videoRec.srcObject = streamRec;
      await videoRec.play();

      recIsRunning = true;
      recStartBtn.disabled = true;
      recStopBtn.disabled = false;
      updateRecorderHeader();
      setStatus("Running");

      recLastFrameTs = 0;
      rafRec = requestAnimationFrame(recorderStep);
    }

    function recorderStop() {
      recIsRunning = false;
      if (rafRec) cancelAnimationFrame(rafRec);
      rafRec = null;
      if (streamRec) { streamRec.getTracks().forEach(t => t.stop()); streamRec = null; }
      videoRec.srcObject = null;

      recStartBtn.disabled = false;
      recStopBtn.disabled = true;
      recStableSince = 0;
      recPrevVec = null;
      recMotionEl.textContent = "—";

      recPredHistory = [];
      recTestRawEl.textContent = "—";
      recTestStableEl.textContent = "—";
      recTestConfEl.textContent = "—";

      updateRecorderHeader();
      setStatus("Idle");
    }

    recStartBtn.addEventListener("click", () => recorderStart().catch(err => {
      console.error(err);
      setStatus("Error");
      alert("Could not start Recorder. Run via http(s) and allow camera.");
      recorderStop();
    }));
    recStopBtn.addEventListener("click", recorderStop);

    recPrevBtn.addEventListener("click", () => {
      recLabelIndex = Math.max(0, recLabelIndex - 1);
      recStableSince = 0; recPrevVec = null;
      recPredHistory = [];
      updateRecorderHeader();
    });
    recNextBtn.addEventListener("click", () => {
      recLabelIndex = Math.min(LABELS.length - 1, recLabelIndex + 1);
      recStableSince = 0; recPrevVec = null;
      recPredHistory = [];
      updateRecorderHeader();
    });

    recResetLetterBtn.addEventListener("click", () => {
      const label = getRecTargetLabel();
      if (!confirm(`Reset samples for letter "${label}" in active profile?`)) return;
      resetCurrentLetterSamples();
    });

    recExportBtn.addEventListener("click", () => {
      persistActiveProfileDataset();
      const active = getActiveProfileName();
      const profiles = loadProfiles();
      const prof = profiles[active];
      downloadJSON(`${active || "profile"}_knn.json`, {
        profile: active,
        mode: prof?.mode || "recording",
        dataset: prof?.datasetJSON || datasetToJSON(knn.getClassifierDataset()),
        exportedAt: new Date().toISOString()
      });
    });

    recImportInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      const obj = JSON.parse(text);
      const dsObj = obj.dataset ? obj.dataset : obj;
      try {
        knn.clearAllClasses();
        knn.setClassifierDataset(jsonToDataset(dsObj));
        persistActiveProfileDataset();
        sampleCountEl.textContent = knn.getNumExamples();
        activeSamplesKpi.textContent = knn.getNumExamples();
        updateRecorderHeader();
        alert("Imported into active profile.");
      } catch (err) {
        console.error(err);
        alert("Import failed. File format not recognized.");
      }
      recImportInput.value = "";
    });

    // -----------------------
    // Profiles UI
    // -----------------------
    profileCreateBtn.addEventListener("click", () => {
      const res = createProfile(newProfileName.value, newProfileMode.value);
      if (!res.ok) { alert(res.msg); return; }
      refreshProfileUI();
      newProfileName.value = "";
      alert("Profile created.");
    });

    profileActivateBtn.addEventListener("click", () => {
      const sel = profileSelect.value;
      if (!sel) return;
      setActiveProfile(sel);
    });

    profileDeleteBtn.addEventListener("click", () => {
      const sel = profileSelect.value;
      if (!sel) return;
      if (!confirm(`Delete profile "${sel}"? This cannot be undone.`)) return;
      deleteProfile(sel);
    });

    switchProfileBtn.addEventListener("click", () => {
      refreshProfileUI();
      profileModal.style.display = "flex";
    });
    profileModalCloseBtn.addEventListener("click", () => profileModal.style.display = "none");
    profileModalActivateBtn.addEventListener("click", () => {
      const sel = profileModalSelect.value;
      if (!sel) return;
      profileModal.style.display = "none";
      setActiveProfile(sel);
    });
    profileModalCreateBtn.addEventListener("click", () => {
      const res = createProfile(profileModalNewName.value, profileModalNewMode.value);
      if (!res.ok) { alert(res.msg); return; }
      profileModal.style.display = "none";
      setActiveProfile(profileModalNewName.value.trim());
      profileModalNewName.value = "";
    });

    // Persist on unload
    window.addEventListener("beforeunload", () => { try { persistActiveProfileDataset(); } catch {} });

    // -----------------------
    // Avatar 2D engine (A)
    // -----------------------
    function sanitizeToAvatarQueue(text) {
      const t = (text || "").toUpperCase();
      const out = [];
      for (const ch of t) {
        if (ch >= "A" && ch <= "Z") out.push(ch);
        else if (ch === " ") out.push("SPACE");
        // ignore other symbols for now
      }
      return out;
    }

    function avatarDrawBackground() {
      const w = avatarCanvas.width, h = avatarCanvas.height;
      const g = avatarCtx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, "#0b0b0b");
      g.addColorStop(1, "#101214");
      avatarCtx.fillStyle = g;
      avatarCtx.fillRect(0, 0, w, h);

      // subtle grid
      avatarCtx.globalAlpha = 0.12;
      avatarCtx.strokeStyle = "#ffffff";
      avatarCtx.lineWidth = 1;
      for (let x = 0; x < w; x += 40) {
        avatarCtx.beginPath();
        avatarCtx.moveTo(x, 0);
        avatarCtx.lineTo(x, h);
        avatarCtx.stroke();
      }
      for (let y = 0; y < h; y += 40) {
        avatarCtx.beginPath();
        avatarCtx.moveTo(0, y);
        avatarCtx.lineTo(w, y);
        avatarCtx.stroke();
      }
      avatarCtx.globalAlpha = 1.0;
    }

    function drawCard(label, subtitle) {
      const w = avatarCanvas.width, h = avatarCanvas.height;
      const cx = w * 0.5, cy = h * 0.5;

      avatarDrawBackground();

      // Card
      const cardW = Math.min(520, w * 0.78);
      const cardH = Math.min(340, h * 0.72);
      const x = cx - cardW/2;
      const y = cy - cardH/2;

      avatarCtx.fillStyle = "rgba(255,255,255,0.06)";
      avatarCtx.strokeStyle = "rgba(255,255,255,0.18)";
      avatarCtx.lineWidth = 2;
      roundRect(avatarCtx, x, y, cardW, cardH, 18, true, true);

      // Letter
      avatarCtx.fillStyle = "rgba(255,255,255,0.92)";
      avatarCtx.font = "900 140px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      avatarCtx.textAlign = "center";
      avatarCtx.textBaseline = "middle";
      avatarCtx.fillText(label === "SPACE" ? "␠" : label, cx, cy - 20);

      avatarCtx.fillStyle = "rgba(255,255,255,0.75)";
      avatarCtx.font = "600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      avatarCtx.fillText(subtitle || "ASL Pose (placeholder)", cx, cy + 110);
    }

    function roundRect(ctx2, x, y, w, h, r, fill, stroke) {
      const rr = Math.min(r, w/2, h/2);
      ctx2.beginPath();
      ctx2.moveTo(x + rr, y);
      ctx2.arcTo(x + w, y, x + w, y + h, rr);
      ctx2.arcTo(x + w, y + h, x, y + h, rr);
      ctx2.arcTo(x, y + h, x, y, rr);
      ctx2.arcTo(x, y, x + w, y, rr);
      ctx2.closePath();
      if (fill) ctx2.fill();
      if (stroke) ctx2.stroke();
    }

    // Minimal stylized “pose drawings” for A–E + SPACE
    function drawPose(label) {
      // Background + header
      avatarDrawBackground();
      const w = avatarCanvas.width, h = avatarCanvas.height;

      avatarCtx.fillStyle = "rgba(255,255,255,0.90)";
      avatarCtx.font = "800 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      avatarCtx.textAlign = "left";
      avatarCtx.textBaseline = "top";
      avatarCtx.fillText("ASL Avatar (2D)", 18, 16);

      avatarCtx.fillStyle = "rgba(255,255,255,0.75)";
      avatarCtx.font = "600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      avatarCtx.fillText("Text → Sign sequence player", 18, 52);

      // big label
      avatarCtx.textAlign = "right";
      avatarCtx.fillStyle = "rgba(255,255,255,0.9)";
      avatarCtx.font = "900 64px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      avatarCtx.fillText(label === "SPACE" ? "SPACE" : label, w - 18, 18);

      // Drawing area
      const areaX = 40, areaY = 110, areaW = w - 80, areaH = h - 150;

      avatarCtx.fillStyle = "rgba(255,255,255,0.06)";
      avatarCtx.strokeStyle = "rgba(255,255,255,0.16)";
      avatarCtx.lineWidth = 2;
      roundRect(avatarCtx, areaX, areaY, areaW, areaH, 18, true, true);

      // draw simple hand-like shape (stylized)
      avatarCtx.save();
      avatarCtx.translate(areaX + areaW/2, areaY + areaH/2);

      // palm
      avatarCtx.fillStyle = "rgba(255,255,255,0.10)";
      avatarCtx.strokeStyle = "rgba(255,255,255,0.30)";
      avatarCtx.lineWidth = 3;

      // Different poses are approximate placeholders (for UX timing).
      if (label === "SPACE") {
        avatarCtx.font = "800 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        avatarCtx.fillStyle = "rgba(255,255,255,0.85)";
        avatarCtx.textAlign = "center";
        avatarCtx.textBaseline = "middle";
        avatarCtx.fillText("Word break", 0, -10);
        avatarCtx.fillStyle = "rgba(255,255,255,0.65)";
        avatarCtx.font = "600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        avatarCtx.fillText("Pause & reset", 0, 22);
        avatarCtx.restore();
        return;
      }

      // palm base
      roundRect(avatarCtx, -90, -30, 180, 220, 40, true, true);

      // thumb + fingers (simple rectangles, different per letter)
      function finger(x, y, w2, h2) {
        avatarCtx.fillStyle = "rgba(255,255,255,0.10)";
        avatarCtx.strokeStyle = "rgba(255,255,255,0.28)";
        roundRect(avatarCtx, x, y, w2, h2, 18, true, true);
      }

      if (label === "A") {
        // fist: short fingers
        finger(-75, -10, 45, 80);
        finger(-25, -10, 45, 80);
        finger(25, -10, 45, 80);
        // thumb on side
        finger(70, 60, 40, 90);
      } else if (label === "B") {
        // open hand: tall fingers
        finger(-75, -170, 45, 160);
        finger(-25, -180, 45, 170);
        finger(25, -170, 45, 160);
        finger(75, -150, 40, 140);
        // thumb folded
        finger(-95, 80, 80, 50);
      } else if (label === "C") {
        // C curve: indicate with arc
        avatarCtx.beginPath();
        avatarCtx.strokeStyle = "rgba(255,255,255,0.40)";
        avatarCtx.lineWidth = 10;
        avatarCtx.arc(0, 40, 120, -0.35*Math.PI, 0.35*Math.PI, false);
        avatarCtx.stroke();
        avatarCtx.lineWidth = 3;
      } else if (label === "D") {
        // index up
        finger(-20, -200, 55, 190);
        finger(-75, -10, 45, 80);
        finger(35, -10, 45, 80);
        // thumb
        finger(80, 70, 35, 80);
      } else if (label === "E") {
        // curled fingers
        finger(-75, -40, 45, 100);
        finger(-25, -50, 45, 110);
        finger(25, -40, 45, 100);
        finger(75, -25, 40, 85);
      } else {
        // fallback for all other letters: card
        avatarCtx.restore();
        drawCard(label, "Letter card (pose coming in 3D VRM)");
        return;
      }

      // caption
      avatarCtx.fillStyle = "rgba(255,255,255,0.70)";
      avatarCtx.font = "600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      avatarCtx.textAlign = "center";
      avatarCtx.textBaseline = "top";
      avatarCtx.fillText("Stylized pose placeholder (A–E). 3D rig comes next.", 0, 210);

      avatarCtx.restore();
    }

    // Player state
    let avatarQueue = [];
    let avatarIndex = 0;
    let avatarTimer = null;
    let avatarIsPaused = false;

    function avatarUpdateKpis() {
      avatarQueueKpi.textContent = String(avatarQueue.length);
      avatarNowEl.textContent = avatarQueue.length ? `${avatarQueue[Math.min(avatarIndex, avatarQueue.length-1)]}` : "—";
    }

    function avatarStop() {
      if (avatarTimer) clearTimeout(avatarTimer);
      avatarTimer = null;
      avatarIsPaused = false;
      avatarIndex = 0;
      avatarUpdateKpis();
      avatarPlayBtn.disabled = false;
      avatarPauseBtn.disabled = true;
      avatarStopBtn.disabled = true;
      drawPose("SPACE");
      avatarNowEl.textContent = "—";
    }

    function avatarPauseToggle() {
      if (!avatarQueue.length) return;
      avatarIsPaused = !avatarIsPaused;
      avatarPauseBtn.textContent = avatarIsPaused ? "Resume" : "Pause";
      if (!avatarIsPaused) avatarTick(); // resume
    }

    function avatarTick() {
      if (avatarIsPaused) return;
      if (avatarIndex >= avatarQueue.length) {
        avatarStop();
        return;
      }

      const symbol = avatarQueue[avatarIndex];
      drawPose(symbol);

      avatarNowEl.textContent = symbol;
      avatarUpdateKpis();

      const speed = Math.max(120, Math.min(2500, parseInt(avatarSpeedMsEl.value || "550", 10)));
      const wordPause = Math.max(0, Math.min(5000, parseInt(avatarWordPauseMsEl.value || "500", 10)));

      const delay = (symbol === "SPACE") ? Math.max(speed, wordPause) : speed;

      avatarIndex++;
      avatarTimer = setTimeout(avatarTick, delay);
    }

    function avatarPlay() {
      avatarQueue = sanitizeToAvatarQueue(avatarTextEl.value);
      avatarIndex = 0;
      avatarIsPaused = false;
      avatarPauseBtn.textContent = "Pause";
      avatarUpdateKpis();

      if (!avatarQueue.length) {
        alert("No playable characters. Use letters A–Z and spaces.");
        return;
      }

      avatarPlayBtn.disabled = true;
      avatarPauseBtn.disabled = false;
      avatarStopBtn.disabled = false;

      avatarTick();
    }

    avatarPlayBtn.addEventListener("click", avatarPlay);
    avatarPauseBtn.addEventListener("click", avatarPauseToggle);
    avatarStopBtn.addEventListener("click", avatarStop);

    avatarUseTranscriptBtn.addEventListener("click", () => {
      avatarTextEl.value = (transcriptEl.value || "").toUpperCase();
      setActiveTab("avatar");
    });
    avatarClearTextBtn.addEventListener("click", () => {
      avatarTextEl.value = "";
      avatarStop();
    });

    // Send transcript button inside Demo tab
    sendTranscriptToAvatarBtn.addEventListener("click", () => {
      avatarTextEl.value = (transcriptEl.value || "").toUpperCase();
      setActiveTab("avatar");
    });

    // -----------------------
    // Boot
    // -----------------------
    ensureDefaultProfiles();
    refreshProfileUI();
    setActiveProfile(getActiveProfileName());
    sampleCountEl.textContent = knn.getNumExamples();
    updateRecorderHeader();
    applyRecPreset("normal");

    rawLabelEl.textContent = "—";
    stableLabelEl.textContent = "—";
    confEl.textContent = "—";
    handInfoEl.textContent = "—";

    // Avatar initial draw
    drawPose("SPACE");

  </script>
</body>
</html>


